<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZKsync SDK</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync SDK</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Learn what the <code>zksync-js</code> is and how it simplifies ZKsync cross-chain flows for <strong>viem</strong> and <strong>ethers</strong>.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The <strong><code>zksync-js</code></strong> is a lightweight extension for <a href="https://viem.sh"><code>viem</code></a> and <a href="https://docs.ethers.io/"><code>ethers</code></a> that makes <strong>ZKsync cross-chain actions simple and consistent</strong>.</p>
<p>Instead of re-implementing accounts or low-level RPC logic, this SDK focuses only on <strong>ZKsync-specific flows</strong>:</p>
<ul>
<li>Deposits (<strong>L1 ‚Üí L2</strong>)</li>
<li>Withdrawals (<strong>L2 ‚Üí L1</strong>, including finalization)</li>
<li><em>Try</em> variants for functional error handling (e.g. <code>tryCreate</code>)</li>
<li>Status and wait helpers</li>
<li>ZKsync-specific JSON-RPC methods</li>
</ul>
<blockquote>
<p>[!INFO]
The SDK doesn‚Äôt replace your existing Ethereum libraries ‚Äî it <strong>extends</strong> them with ZKsync-only
capabilities while keeping your current tooling intact.</p>
</blockquote>
<h2 id="key-supported-features"><a class="header" href="#key-supported-features">Key Supported Features</a></h2>
<h3 id="deposits-l1--l2"><a class="header" href="#deposits-l1--l2">Deposits (L1 ‚Üí L2)</a></h3>
<p>Supports ETH, Custom Base Token, and ERC-20.</p>
<ul>
<li><strong>Initiate on L1:</strong> Build and send the deposit transaction from Ethereum.</li>
<li><strong>Track progress:</strong> Query intermediate states (queued, included, executed).</li>
<li><strong>Verify completion on L2:</strong> Confirm funds credited and available on ZKsync.</li>
</ul>
<h3 id="withdrawals-l2--l1"><a class="header" href="#withdrawals-l2--l1">Withdrawals (L2 ‚Üí L1)</a></h3>
<p>Supports ETH, Custom Base Token, and ERC-20.</p>
<ul>
<li><strong>Initiate on L2:</strong> Create the withdrawal transaction on ZKsync.</li>
<li><strong>Track progress:</strong> Monitor execution and finalization availability.</li>
<li><strong>Finalize on L1:</strong> Finalize withdrawal to release funds back to Ethereum.</li>
</ul>
<h3 id="zksync-rpc-extensions"><a class="header" href="#zksync-rpc-extensions">ZKsync RPC Extensions</a></h3>
<ul>
<li><strong><code>getBridgehubAddress</code></strong> (<code>zks_getBridgehubContract</code>) ‚Äî resolve the canonical Bridgehub contract address.</li>
<li><strong><code>getBytecodeSupplierAddress</code></strong> (<code>zks_getBytecodeSupplierContract</code>) ‚Äî resolve the Bytecode Supplier contract address.</li>
<li><strong><code>getL2ToL1LogProof</code></strong> (<code>zks_getL2ToL1LogProof</code>) ‚Äî retrieve the log proof for an L2 ‚Üí L1 transaction.</li>
<li><strong><code>getReceiptWithL2ToL1</code></strong> ‚Äî returns a standard Ethereum <code>TransactionReceipt</code> <strong>augmented</strong> with <code>l2ToL1Logs</code>.</li>
<li><strong><code>getBlockMetadataByNumber</code></strong> (<code>zks_getBlockMetadataByNumber</code>) ‚Äî fetch block metadata (pubdata price, native price, execution version).</li>
<li><strong><code>getGenesis</code></strong> (<code>zks_getGenesis</code>) - returns Genesis json.</li>
</ul>
<h2 id="what-youll-find-here"><a class="header" href="#what-youll-find-here">What You‚Äôll Find Here</a></h2>
<ul>
<li><a href="overview/./overview/mental-model.html"><strong>Mental Model</strong></a> ‚Äî understand the core flow:
<code>quote ‚Üí prepare ‚Üí create ‚Üí status ‚Üí wait ‚Üí finalize</code>.</li>
<li><a href="overview/./overview/adapters.html"><strong>Adapters (viem &amp; ethers)</strong></a> ‚Äî how the SDK integrates with your existing stack.</li>
<li><a href="overview/./overview/finalization.html"><strong>Withdrawal Finalization</strong></a> ‚Äî learn the finalization process and how to ensure withdrawals are completed.</li>
</ul>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>üëâ Ready to build? Start with the <a href="overview/../quickstart/index.html"><strong>Quickstart</strong></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mental-model"><a class="header" href="#mental-model">Mental Model</a></h1>
<p>The SDK is designed around a predictable and layered API for handling L1-L2, and L2-L1 operations. Every action, whether it's a deposit or a withdrawal, follows a consistent lifecycle. Understanding this lifecycle is key to using the SDK effectively.</p>
<p>The complete lifecycle for any action is:</p>
<pre><code class="language-bash">quote ‚Üí prepare ‚Üí create ‚Üí status ‚Üí wait ‚Üí (finalize*)
</code></pre>
<ul>
<li>The first five steps are common to both <strong>Deposits</strong> and <strong>Withdrawals</strong>.</li>
<li>Withdrawals require an additional <strong><code>finalize</code></strong> step to prove and claim the funds on L1.</li>
</ul>
<p>You can enter this lifecycle at different stages depending on how much control you need.</p>
<h2 id="the-core-api-a-layered-approach"><a class="header" href="#the-core-api-a-layered-approach">The Core API: A Layered Approach</a></h2>
<p>The core methods are designed to give you progressively more automation. You can start by just getting information (<code>quote</code>), move to building transactions without sending them (<code>prepare</code>), or execute the entire flow with a single call (<code>create</code>).</p>
<h3 id="quoteparams"><a class="header" href="#quoteparams"><code>quote(params)</code></a></h3>
<p><em>"What will this operation involve and cost?"</em></p>
<p>This is a <strong>read-only</strong> dry run. It performs no transactions and has no side effects. It inspects the parameters and returns a <code>Quote</code> object containing the estimated fees, gas costs, and the steps the SDK will take to complete the action.</p>
<p>‚û°Ô∏è <strong>Best for:</strong> Displaying a confirmation screen to a user with a cost estimate before they commit.</p>
<h3 id="prepareparams"><a class="header" href="#prepareparams"><code>prepare(params)</code></a></h3>
<p><em>"Build the transactions for me, but let me send them."</em></p>
<p>This method constructs all the necessary transactions for the operation and returns them as an array of <code>TransactionRequest</code> objects in a <code>Plan</code>. It does <strong>not</strong> sign or send them. This gives you full control over the final execution.</p>
<p>‚û°Ô∏è <strong>Best for:</strong> Custom workflows where you need to inspect transactions before signing, use a unique signing method, or submit them through a separate system (like a multisig).</p>
<h3 id="createparams"><a class="header" href="#createparams"><code>create(params)</code></a></h3>
<p><em>"Prepare, sign, and send in one go."</em></p>
<p>This is the most common entry point for a one-shot operation. It internally calls <code>prepare</code>, then uses your configured signer to sign and dispatch the transactions. It returns a <code>Handle</code> object, which is a lightweight tracker containing the transaction hash(es) needed for the next steps.</p>
<p>‚û°Ô∏è <strong>Best for:</strong> Most standard use cases where you simply want to initiate the deposit or withdrawal.</p>
<h3 id="statushandle--txhash"><a class="header" href="#statushandle--txhash"><code>status(handle | txHash)</code></a></h3>
<p><em>"Where is my transaction right now?"</em></p>
<p>This is a <strong>non-blocking</strong> check to get the current state of an operation. It takes a <code>Handle</code> from the <code>create</code> method or a transaction hash and returns a structured status object, such as:</p>
<ul>
<li><strong>Deposits:</strong> <code>{ phase: 'L1_PENDING' | 'L2_EXECUTED' }</code></li>
<li><strong>Withdrawals:</strong> <code>{ phase: 'L1_INCLUDED','L2_PENDING' | 'READY_TO_FINALIZE' | 'FINALIZED' }</code></li>
</ul>
<p>‚û°Ô∏è <strong>Best for:</strong> Polling in a UI to show a user the live progress of their transaction without blocking the interface.</p>
<h3 id="waithandle--for-"><a class="header" href="#waithandle--for-"><code>wait(handle, { for })</code></a></h3>
<p><em>"Pause until a specific checkpoint is reached."</em></p>
<p>This is a <strong>blocking</strong> (asynchronous) method that polls for you. It pauses execution until the operation reaches a desired checkpoint and then resolves with the relevant transaction receipt.</p>
<ul>
<li><strong>Deposits:</strong> Wait for L1 inclusion (<code>'l1'</code>) or L2 execution (<code>'l2'</code>).</li>
<li><strong>Withdrawals:</strong> Wait for L2 inclusion (<code>'l2'</code>), finalization availability (<code>'ready'</code>), or final L1 finalization (<code>'finalized'</code>).</li>
</ul>
<p>‚û°Ô∏è <strong>Best for:</strong> Scripts or backend processes where you need to ensure one step is complete before starting the next.</p>
<h3 id="finalizel2txhash"><a class="header" href="#finalizel2txhash"><code>finalize(l2TxHash)</code></a></h3>
<p><em>(Withdrawals Only)</em></p>
<p><em>"My funds are ready on L1. Finalize and release them."</em></p>
<p>This method executes the final step of a withdrawal. After <code>status</code> reports <code>READY_TO_FINALIZE</code>, you call this method with the L2 transaction hash to submit the finalization transaction on L1, which releases the funds to the recipient.</p>
<p>‚û°Ô∏è <strong>Best for:</strong> The final step of any withdrawal flow.</p>
<h2 id="error-handling-the-try-philosophy"><a class="header" href="#error-handling-the-try-philosophy">Error Handling: The <code>try*</code> Philosophy</a></h2>
<p>For more robust error handling without <code>try/catch</code> blocks, <strong>every core method has a <code>try*</code> variant</strong> (e.g., <code>tryQuote</code>, <code>tryCreate</code>).</p>
<p>Instead of throwing an error on failure, these methods return a result object that enforces explicit error handling:</p>
<pre><code class="language-ts">// Instead of this:
try {
  const handle = await sdk.withdrawals.create(params);
  // ... happy path
} catch (error) {
  // ... sad path
}

// You can do this:
const result = await sdk.withdrawals.tryCreate(params);

if (result.ok) {
  // Safe to use result.value, which is the WithdrawHandle
  const handle = result.value;
} else {
  // Handle the error explicitly
  console.error('Withdrawal failed:', result.error);
}
</code></pre>
<p>‚û°Ô∏è <strong>Best for:</strong> Applications that prefer a functional error-handling pattern and want to avoid uncaught exceptions.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>These primitives allow you to compose flows that are as simple or as complex as you need.</p>
<h4 id="simple-flow"><a class="header" href="#simple-flow">Simple Flow</a></h4>
<p>Use <code>create</code> and <code>wait</code> for the most straightforward path.</p>
<pre><code class="language-ts">// 1. Create the deposit
const depositHandle = await sdk.deposits.create(params);

// 2. Wait for it to be finalized on L2
const receipt = await sdk.deposits.wait(depositHandle, { for: 'l2' });

console.log('Deposit complete!');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adapters-viem--ethers"><a class="header" href="#adapters-viem--ethers">Adapters: <code>viem</code> &amp; <code>ethers</code></a></h1>
<p>The SDK is designed to work <em>with</em> the tools you already know and love. It's not a standalone library, but rather an extension that plugs into your existing <code>viem</code> or <code>ethers.js</code> setup.</p>
<p>Think of it like a power adapter üîå. You have your device (<code>viem</code> or <code>ethers</code> client), and this SDK adapts it to work seamlessly with zkSync's unique features. You bring your own client, and the SDK enhances it.</p>
<h2 id="why-an-adapter-model"><a class="header" href="#why-an-adapter-model">Why an Adapter Model?</a></h2>
<p>This approach offers several key advantages:</p>
<ul>
<li>‚úÖ <strong>Bring Your Own Stack:</strong> You don't have to replace your existing setup. The SDK integrates directly with the <code>viem</code> clients (<code>PublicClient</code>, <code>WalletClient</code>) or <code>ethers</code> providers and signers you're already using.</li>
<li>üìö <strong>Familiar Developer Experience (DX):</strong> You continue to handle connections, accounts, and signing just as you always have.</li>
<li>üß© <strong>Lightweight &amp; Focused:</strong> The SDK remains small and focused on one thing: providing a robust API for ZKsync-specific actions like deposits and withdrawals.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>First, install the core SDK, then add the adapter that matches your project's stack.</p>
<pre><code class="language-bash"># For viem users
npm install @matterlabs/zksync-js viem

# For ethers.js users
npm install @matterlabs/zksync-js ethers
</code></pre>
<h2 id="how-to-use"><a class="header" href="#how-to-use">How to Use</a></h2>
<p>The SDK extends your existing client. Configure <strong>viem</strong> or <strong>ethers</strong> as you normally would, then pass them into the adapter‚Äôs client factory and create the SDK surface.</p>
<h3 id="viem-public--wallet-client"><a class="header" href="#viem-public--wallet-client">viem (public + wallet client)</a></h3>
<pre><code class="language-ts">import { createPublicClient, createWalletClient, http, parseEther } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);

const l1 = createPublicClient({ transport: http(process.env.L1_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.L2_RPC!) });
const l1Wallet = createWalletClient({ account, transport: http(process.env.L1_RPC!) });

const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);

const params = {
  amount: parseEther('0.01'),
  to: account.address,
  token: ETH_ADDRESS,
} as const;

const handle = await sdk.deposits.create(params);
await sdk.deposits.wait(handle, { for: 'l2' }); // funds available on L2
</code></pre>
<h3 id="ethers-providers--signer"><a class="header" href="#ethers-providers--signer">ethers (providers + signer)</a></h3>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const l1 = new JsonRpcProvider(process.env.L1_RPC!);
const l2 = new JsonRpcProvider(process.env.L2_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = await createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);

const params = {
  amount: parseEther('0.01'),
  to: await signer.getAddress(),
  token: ETH_ADDRESS,
} as const;

const handle = await sdk.deposits.create(params);
await sdk.deposits.wait(handle, { for: 'l2' }); // funds available on L2
</code></pre>
<hr />
<h2 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h2>
<ul>
<li><strong>No Key Management:</strong> The SDK never asks for or stores private keys. All signing operations are delegated to the <code>viem</code> <code>WalletClient</code> or <code>ethers</code> <code>Signer</code> you provide.</li>
<li><strong>API Parity:</strong> Both adapters expose the exact same API. The code you write to call <code>client.deposits.quote()</code> is identical whether you're using <code>viem</code> or <code>ethers</code>.</li>
<li><strong>Easy Migration:</strong> Because the API is the same, switching your project from <code>ethers</code> to <code>viem</code> (or vice versa) is incredibly simple. You only need to change the initialization code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="status-vs-wait"><a class="header" href="#status-vs-wait">Status vs Wait</a></h1>
<p>Snapshot progress with <code>status(...)</code> or block until a checkpoint with <code>wait(..., { for })</code> for deposits and withdrawals.</p>
<p>The SDK exposes two complementary ways to track progress:</p>
<ul>
<li><strong><code>status(...)</code></strong> ‚Äî returns a <strong>non-blocking snapshot</strong> of where an operation is.</li>
<li><strong><code>wait(..., { for })</code></strong> ‚Äî <strong>blocks/polls</strong> until a specified checkpoint is reached.</li>
</ul>
<p>Both apply to <strong>deposits</strong> and <strong>withdrawals</strong>.
Use <code>status(...)</code> for UI refreshes; use <code>wait(...)</code> when you need to gate logic on inclusion/finality.</p>
<blockquote>
<p>[!NOTE]
You can pass <strong>either</strong> a handle returned from <code>create(...)</code> <strong>or</strong> a raw transaction hash.</p>
</blockquote>
<h2 id="withdrawals"><a class="header" href="#withdrawals">Withdrawals</a></h2>
<h3 id="withdrawalsstatush--l2txhash-promisewithdrawalstatus"><a class="header" href="#withdrawalsstatush--l2txhash-promisewithdrawalstatus"><code>withdrawals.status(h | l2TxHash): Promise&lt;WithdrawalStatus&gt;</code></a></h3>
<p><strong>Input</strong></p>
<ul>
<li><code>h</code>: a <code>WithdrawalWaitable</code> (e.g., from <code>create</code>) <strong>or</strong> the L2 transaction hash <code>Hex</code>.</li>
</ul>
<p><strong>Phases</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>Handle doesn‚Äôt contain an L2 hash yet.</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 transaction not yet included.</td></tr>
<tr><td><code>PENDING</code></td><td>L2 included, <strong>not</strong> yet ready to finalize on L1.</td></tr>
<tr><td><code>READY_TO_FINALIZE</code></td><td>Finalization on L1 would succeed now.</td></tr>
<tr><td><code>FINALIZED</code></td><td>Finalized on L1; funds released.</td></tr>
</tbody></table>
</div>
<p><strong>Notes</strong></p>
<ul>
<li>No L2 receipt ‚áí <code>L2_PENDING</code></li>
<li>Finalization key derivable but not ready ‚áí <code>PENDING</code></li>
<li>Already finalized ‚áí <code>FINALIZED</code></li>
</ul>
<details>
<summary><code>withdrawals-status.ts</code></summary>
<pre><code class="language-ts">const s = await sdk.withdrawals.status(handleOrHash);
// s.phase ‚àà 'UNKNOWN' | 'L2_PENDING' | 'PENDING' | 'READY_TO_FINALIZE' | 'FINALIZED'
</code></pre>
</details>
<h3 id="withdrawalswaith--l2txhash--for-pollms-timeoutms-"><a class="header" href="#withdrawalswaith--l2txhash--for-pollms-timeoutms-"><code>withdrawals.wait(h | l2TxHash, { for, pollMs?, timeoutMs? })</code></a></h3>
<p><strong>Targets</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Target</th><th>Resolves with</th><th></th></tr></thead><tbody>
<tr><td><code>{ for: 'l2' }</code></td><td><strong>L2 receipt</strong> (`TransactionReceipt</td><td>null`)</td></tr>
<tr><td><code>{ for: 'ready' }</code></td><td><strong><code>null</code></strong> when finalization becomes possible</td><td></td></tr>
<tr><td><code>{ for: 'finalized' }</code></td><td><strong>L1 receipt</strong> when finalized, or <code>null</code> if finalized but receipt not found</td><td></td></tr>
</tbody></table>
</div>
<p><strong>Behavior</strong></p>
<ul>
<li>If the handle has <strong>no L2 hash</strong>, returns <code>null</code> immediately.</li>
<li>Default polling interval: <strong>5500 ms</strong> (override with <code>pollMs</code>).</li>
<li><code>timeoutMs</code> ‚Üí returns <code>null</code> on deadline.</li>
</ul>
<details>
<summary><code>withdrawals-wait.ts</code></summary>
<pre><code class="language-ts">// Wait for L2 inclusion ‚Üí get L2 receipt (augmented with l2ToL1Logs if available)
const l2Rcpt = await sdk.withdrawals.wait(handle, { for: 'l2', pollMs: 5000 });

// Wait until it becomes finalizable (no side effects)
await sdk.withdrawals.wait(handle, { for: 'ready' });

// Wait for L1 finalization ‚Üí L1 receipt (or null if not retrievable)
const l1Rcpt = await sdk.withdrawals.wait(handle, { for: 'finalized', timeoutMs: 15 * 60_000 });
</code></pre>
</details>
<blockquote>
<p>[!TIP]
Building a UI? Use <code>status(...)</code> to paint the current phase and enable/disable the <strong>Finalize</strong> button when the phase is <code>READY_TO_FINALIZE</code>.</p>
</blockquote>
<h2 id="deposits"><a class="header" href="#deposits">Deposits</a></h2>
<h3 id="depositsstatush--l1txhash-promisedepositstatus"><a class="header" href="#depositsstatush--l1txhash-promisedepositstatus"><code>deposits.status(h | l1TxHash): Promise&lt;DepositStatus&gt;</code></a></h3>
<p><strong>Input</strong></p>
<ul>
<li><code>h</code>: a <code>DepositWaitable</code> (from <code>create</code>) <strong>or</strong> L1 transaction hash <code>Hex</code>.</li>
</ul>
<p><strong>Phases</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>No L1 hash present on the handle.</td></tr>
<tr><td><code>L1_PENDING</code></td><td>L1 receipt missing.</td></tr>
<tr><td><code>L1_INCLUDED</code></td><td>L1 included; L2 hash not yet derivable from logs.</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 hash known but L2 receipt missing.</td></tr>
<tr><td><code>L2_EXECUTED</code></td><td>L2 receipt present with <code>status === 1</code>.</td></tr>
<tr><td><code>L2_FAILED</code></td><td>L2 receipt present with <code>status !== 1</code>.</td></tr>
</tbody></table>
</div><details>
<summary><code>deposits-status.ts</code></summary>
<pre><code class="language-ts">const s = await sdk.deposits.status(handleOrL1Hash);
// s.phase ‚àà 'UNKNOWN' | 'L1_PENDING' | 'L1_INCLUDED' | 'L2_PENDING' | 'L2_EXECUTED' | 'L2_FAILED'
</code></pre>
</details>
<h3 id="depositswaith--l1txhash--for-l1--l2-"><a class="header" href="#depositswaith--l1txhash--for-l1--l2-"><code>deposits.wait(h | l1TxHash, { for: 'l1' | 'l2' })</code></a></h3>
<p><strong>Targets</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Target</th><th>Resolves with</th></tr></thead><tbody>
<tr><td><code>{ for: 'l1' }</code></td><td><strong>L1 receipt</strong> or <code>null</code></td></tr>
<tr><td><code>{ for: 'l2' }</code></td><td><strong>L2 receipt</strong> or <code>null</code> (waits L1 inclusion <strong>then</strong> L2 execution)</td></tr>
</tbody></table>
</div><details>
<summary><code>deposits-wait.ts</code></summary>
<pre><code class="language-ts">const l1Rcpt = await sdk.deposits.wait(handle, { for: 'l1' });
const l2Rcpt = await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
</details>
<blockquote>
<p>[!NOTE]
<code>wait(..., { for: 'l2' })</code> waits for both <strong>L1 inclusion</strong> and <strong>canonical L2 execution</strong>.</p>
</blockquote>
<h2 id="practical-patterns"><a class="header" href="#practical-patterns">Practical Patterns</a></h2>
<h3 id="pick-the-right-tool"><a class="header" href="#pick-the-right-tool">Pick the Right Tool</a></h3>
<ul>
<li><strong>Use <code>status(...)</code></strong> for <strong>poll-less UI refreshes</strong> (e.g., on page focus or controlled intervals).</li>
<li><strong>Use <code>wait(...)</code></strong> for <strong>workflow gating</strong> (scripts, jobs, or ‚Äúcontinue when X happens‚Äù).</li>
</ul>
<h3 id="timeouts--polling"><a class="header" href="#timeouts--polling">Timeouts &amp; Polling</a></h3>
<details>
<summary><code>polling.ts</code></summary>
<pre><code class="language-ts">const ready = await sdk.withdrawals.wait(handle, {
  for: 'ready',
  pollMs: 5500, // minimum enforced internally
  timeoutMs: 30 * 60_000, // 30 minutes ‚Üí returns null on deadline
});
if (ready === null) {
  // timeout or not yet finalizable ‚Äî decide whether to retry or show a hint
}
</code></pre>
</details>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<ul>
<li>Network hiccup while fetching receipts ‚áí throws <code>ZKsyncError</code> of kind <strong><code>RPC</code></strong>.</li>
<li>Internal decode issue ‚áí throws <code>ZKsyncError</code> of kind <strong><code>INTERNAL</code></strong>.</li>
</ul>
<p>Prefer <strong>no-throw</strong> variants if you want explicit flow control:</p>
<details>
<summary><code>no-throw.ts</code></summary>
<pre><code class="language-ts">const r = await sdk.withdrawals.tryWait(handle, { for: 'finalized' });
if (!r.ok) {
  console.error('Finalize wait failed:', r.error);
} else {
  console.log('Finalized L1 receipt:', r.value);
}
</code></pre>
</details>
<hr />
<h2 id="tips--edge-cases"><a class="header" href="#tips--edge-cases">Tips &amp; Edge Cases</a></h2>
<ul>
<li><strong>Handles vs hashes:</strong> Passing a handle without the relevant hash yields <code>UNKNOWN</code> / <code>null</code>. If you already have a hash, pass it directly.</li>
<li><strong>Finalization windows:</strong> For withdrawals, <code>READY_TO_FINALIZE</code> may take a while. Use <code>status(...)</code> for responsive UI and reserve <code>wait(..., { for: 'finalized' })</code> for blocking logic.</li>
<li><strong>Retries:</strong> If a <code>wait</code> returns <code>null</code> because of <code>timeoutMs</code>, safely call <code>status(...)</code> to decide whether to retry or surface user guidance.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finalization-withdrawals"><a class="header" href="#finalization-withdrawals">Finalization (Withdrawals)</a></h1>
<p><strong>Withdrawals from ZKsync (L2)</strong> only complete on <strong>Ethereum (L1)</strong> after you explicitly call <code>finalize</code>.</p>
<p>When withdrawing from ZKsync (L2) back to Ethereum (L1), <strong>funds are <em>not</em> automatically released on L1</strong> after your L2 transaction is included.</p>
<p>Withdrawals are a <strong>two-step process</strong>:</p>
<ol>
<li><strong>Initiate on L2</strong> ‚Äî call <code>withdraw()</code> (via the SDK‚Äôs <code>create</code>) to start the withdrawal.
This burns or locks funds on L2 and emits logs; <strong>funds are still unavailable on L1</strong>.</li>
<li><strong>Finalize on L1</strong> ‚Äî call <strong><code>finalize(l2TxHash)</code></strong> to release funds on L1.
This submits an L1 transaction; only then does your ETH or token balance increase on Ethereum.</li>
</ol>
<blockquote>
<p>[!WARNING]
If you <strong>never finalize</strong>, your funds remain locked ‚Äî visible as ‚Äúready to withdraw,‚Äù but unavailable on L1.
Anyone can finalize on your behalf, but typically <strong>you</strong> should do it.</p>
</blockquote>
<h2 id="why-finalization-matters"><a class="header" href="#why-finalization-matters">Why Finalization Matters</a></h2>
<ul>
<li><strong>Funds remain locked</strong> until finalized.</li>
<li><strong>Anyone can finalize</strong> ‚Äî typically the withdrawer does.</li>
<li><strong>Finalization costs L1 gas</strong> ‚Äî budget for it.</li>
</ul>
<h2 id="finalization-methods"><a class="header" href="#finalization-methods">Finalization Methods</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>withdrawals.status(h | l2TxHash)</code></td><td>Snapshot phase (<code>UNKNOWN</code> ‚Üí <code>FINALIZED</code>)</td><td><code>WithdrawalStatus</code></td></tr>
<tr><td><code>withdrawals.wait(h | l2TxHash, { for })</code></td><td>Block until a checkpoint (<code>'l2' | 'ready' | 'finalized'</code>)</td><td>Receipt or <code>null</code></td></tr>
<tr><td><code>withdrawals.finalize(l2TxHash)</code></td><td><strong>Send</strong> the L1 finalize transaction</td><td><code>{ status, receipt }</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE]
All methods accept either a <strong>handle</strong> (from <code>create</code>) or a <strong>raw L2 transaction hash</strong>.
If you only have the hash, you can still finalize.</p>
</blockquote>
<h2 id="phases"><a class="header" href="#phases">Phases</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>Handle doesn‚Äôt contain an L2 hash yet.</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 transaction not yet included.</td></tr>
<tr><td><code>PENDING</code></td><td>L2 included, but not yet ready to finalize on L1.</td></tr>
<tr><td><code>READY_TO_FINALIZE</code></td><td>Finalization on L1 would succeed now.</td></tr>
<tr><td><code>FINALIZED</code></td><td>Finalized on L1; funds released.</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<details>
<summary><code>finalize-by-handle.ts</code></summary>
<pre><code class="language-ts">// 1) Create on L2
const withdrawal = await sdk.withdrawals.create({
  token: ETH_ADDRESS,
  amount: parseEther('0.1'),
  to: myAddress,
});

// 2) Wait until finalizable (no side effects)
await sdk.withdrawals.wait(withdrawal, { for: 'ready', pollMs: 5500 });

// 3) Finalize on L1
const { status, receipt } = await sdk.withdrawals.finalize(withdrawal.l2TxHash);

console.log(status.phase); // "FINALIZED"
console.log(receipt?.transactionHash); // L1 finalize tx hash
</code></pre>
</details>
<details>
<summary><code>finalize-by-hash.ts</code></summary>
<pre><code class="language-ts">// If you only have the L2 tx hash:
const l2TxHash = '0x...';

// Optionally confirm readiness first
const s = await sdk.withdrawals.status(l2TxHash);
if (s.phase !== 'READY_TO_FINALIZE') {
  await sdk.withdrawals.wait(l2TxHash, { for: 'ready', timeoutMs: 30 * 60_000 });
}

// Then finalize
const { status, receipt } = await sdk.withdrawals.finalize(l2TxHash);
</code></pre>
</details>
<p>Prefer "no-throw" variants in UI/services that need explicit flow control.</p>
<pre><code class="language-ts">const r = await sdk.withdrawals.tryFinalize(l2TxHash);
if (!r.ok) {
  console.error('Finalize failed:', r.error);
} else {
  console.log('Finalized on L1:', r.value.receipt?.transactionHash);
}
</code></pre>
<h2 id="operational-tips"><a class="header" href="#operational-tips">Operational Tips</a></h2>
<ul>
<li><strong>Gate UX with phases:</strong> Display a <strong>Finalize</strong> button only when <code>status.phase === 'READY_TO_FINALIZE'</code>.</li>
<li><strong>Polling cadence:</strong> <code>wait(..., { for: 'ready' })</code> defaults to ~<strong>5500 ms</strong>. Adjust with <code>pollMs</code> as needed.</li>
<li><strong>Timeouts:</strong> Use <code>timeoutMs</code> for long windows and fall back to <code>status(...)</code> to keep UIs responsive.</li>
<li><strong>Receipts may be <code>null</code>:</strong> <code>wait(..., { for: 'finalized' })</code> can resolve to <code>null</code> if finalized but receipt is unavailable; show an L1 explorer link based on the submitted transaction hash.</li>
</ul>
<h2 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Action</th></tr></thead><tbody>
<tr><td><code>RPC</code></td><td>RPC or network hiccup (<code>ZKsyncError: RPC</code>)</td><td>Retry with backoff.</td></tr>
<tr><td><code>INTERNAL</code></td><td>Decode or internal issue (<code>ZKsyncError: INTERNAL</code>)</td><td>Capture logs and report.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="overview/../overview/status-vs-wait.html">Status vs Wait</a></li>
<li><a href="overview/../guides/withdrawals.html">Withdrawals Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>The Quickstart guides help you get your first ZKsync deposit action running in minutes.<br />
You‚Äôll learn how to install the SDK, connect a client, and perform a deposit.</p>
<h2 id="choose-your-adapter"><a class="header" href="#choose-your-adapter">Choose your adapter</a></h2>
<p>This SDK extends existing Ethereum libraries. Pick the Quickstart that matches your stack:</p>
<ul>
<li><a href="quickstart/viem.html">Quickstart (viem)</a> ‚Äî for projects already using <strong>viem</strong>.</li>
<li><a href="quickstart/ethers.html">Quickstart (ethers)</a> ‚Äî for projects using <strong>ethers v6</strong>.</li>
</ul>
<h2 id="what-youll-do"><a class="header" href="#what-youll-do">What you‚Äôll do</a></h2>
<p>Each Quickstart walks you through:</p>
<ol>
<li><strong>Install</strong> the adapter package.</li>
<li><strong>Configure</strong> a client or signer.</li>
<li><strong>Run</strong> a deposit (L1 ‚Üí L2) as a working example.</li>
<li><strong>Track</strong> the status until it‚Äôs complete.</li>
</ol>
<p>üëâ Once you‚Äôre set up, continue to the <a href="quickstart/../guides/index.html">How-to Guides</a> for more detailed usage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-your-adapter-viem-vs-ethers"><a class="header" href="#choosing-your-adapter-viem-vs-ethers">Choosing Your Adapter: <code>viem</code> vs. <code>ethers</code></a></h1>
<p>The SDK is designed to work with both <code>viem</code> and <code>ethers.js</code>, the two most popular Ethereum libraries. Since the SDK offers <strong>identical functionality</strong> for both, the choice comes down to your project's needs and your personal preference.</p>
<h2 id="the-short-answer-tldr"><a class="header" href="#the-short-answer-tldr">The Short Answer (TL;DR)</a></h2>
<ul>
<li><strong>If you're adding the SDK to an existing project:</strong> Use the adapter for the library you're already using.</li>
<li><strong>If you're starting a new project:</strong> The choice is yours. <code>viem</code> is generally recommended for new projects due to its modern design, smaller bundle size, and excellent TypeScript support.</li>
</ul>
<p>You can't make a wrong choice. Both adapters are fully supported and provide the same features.</p>
<h2 id="code-comparison"><a class="header" href="#code-comparison">Code Comparison</a></h2>
<p>The only difference in your code is the initial setup. <strong>All subsequent SDK calls are identical.</strong></p>
<h4 id="viem"><a class="header" href="#viem">viem</a></h4>
<pre><code class="language-ts">import { createPublicClient, createWalletClient, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';

const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);

const l1 = createPublicClient({ transport: http(process.env.L1_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.L2_RPC!) });
const l1Wallet = createWalletClient({ account, transport: http(process.env.L1_RPC!) });

const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);
</code></pre>
<h4 id="ethers"><a class="header" href="#ethers">ethers</a></h4>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.L1_RPC!);
const l2 = new JsonRpcProvider(process.env.L2_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = await createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);
</code></pre>
<h3 id="identical-sdk-usage"><a class="header" href="#identical-sdk-usage">Identical SDK Usage</a></h3>
<p>Once the adapter is set up, <strong>your application logic is the same</strong>:</p>
<pre><code class="language-ts">const quote = await sdk.deposits.quote({
  token: ETH_ADDRESS,
  amount: parseEther('0.1'),
  to: '0xYourAddress',
});

console.log('Total fee:', quote.totalFee.toString());
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The adapter model is designed to give you flexibility without adding complexity. Your choice of adapter is a low-stakes decision that's easy to change later.</p>
<p><strong>Ready to start building?</strong> üöÄ</p>
<ul>
<li><a href="quickstart/./viem.html"><strong>Go to Quickstart (viem)</strong></a></li>
<li><a href="quickstart/./ethers.html"><strong>Go to Quickstart (ethers)</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-viem-eth-deposit-l1--l2"><a class="header" href="#quickstart-viem-eth-deposit-l1--l2">Quickstart (viem): ETH Deposit (L1 ‚Üí L2)</a></h1>
<p>This guide gets you to a working <strong>ETH deposit from Ethereum to ZKsync (L2)</strong> using the <strong>viem</strong> adapter.</p>
<p>You‚Äôll set up your environment, write a short script, and run it.</p>
<h2 id="1-prerequisites"><a class="header" href="#1-prerequisites">1. Prerequisites</a></h2>
<ul>
<li>You have <a href="https://bun.sh/">Bun</a> (or Node + tsx) installed.</li>
<li>You have an <strong>L1 wallet</strong> funded with ETH to cover the deposit amount <strong>and</strong> L1 gas.</li>
</ul>
<h2 id="2-installation--setup"><a class="header" href="#2-installation--setup">2. Installation &amp; Setup</a></h2>
<p>Install packages:</p>
<pre><code class="language-bash">bun install @matterlabs/zksync-js viem dotenv
# or: npm i @matterlabs/zksync-js viem dotenv
</code></pre>
<p>Create an <code>.env</code> in your project root (never commit this):</p>
<pre><code class="language-env"># Your funded L1 private key (0x + 64 hex)
PRIVATE_KEY=0xYOUR_PRIVATE_KEY_HERE

# RPC endpoints
L1_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_ID
L2_RPC_URL=ZKSYNC-OS-TESTNET-RPC
</code></pre>
<h2 id="3-the-deposit-script"><a class="header" href="#3-the-deposit-script">3. The Deposit Script</a></h2>
<p>Save as <code>deposit-viem.ts</code>:</p>
<pre><code class="language-ts">import 'dotenv/config'; // Load environment variables from .env
import { createPublicClient, createWalletClient, http, parseEther } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const PRIVATE_KEY = process.env.PRIVATE_KEY;
const L1_RPC_URL = process.env.L1_RPC_URL;
const L2_RPC_URL = process.env.L2_RPC_URL;

async function main() {
  if (!PRIVATE_KEY || !L1_RPC_URL || !L2_RPC_URL) {
    throw new Error('Please set your PRIVATE_KEY, L1_RPC_URL, and L2_RPC_URL in a .env file');
  }

  // 1. SET UP CLIENTS AND ACCOUNT
  // The SDK needs connections to both L1 and L2 to function.
  const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);

  const l1 = createPublicClient({ transport: http(L1_RPC_URL) });
  const l2 = createPublicClient({ transport: http(L2_RPC_URL) });
  const l1Wallet = createWalletClient({ account, transport: http(L1_RPC_URL) });

  // 2. INITIALIZE THE SDK CLIENT
  // The client bundles your viem clients; the SDK surface exposes deposits/withdrawals helpers.
  const client = createViemClient({ l1, l2, l1Wallet });
  const sdk = createViemSdk(client);

  const L1balance = await l1.getBalance({ address: account.address });
  const L2balance = await l2.getBalance({ address: account.address });

  console.log('Wallet balance on L1:', L1balance);
  console.log('Wallet balance on L2:', L2balance);

  // 3. PERFORM THE DEPOSIT
  // The create() method prepares and sends the transaction.
  // The wait() method polls until the transaction is complete.
  console.log('Sending deposit transaction...');
  const depositHandle = await sdk.deposits.create({
    token: ETH_ADDRESS,
    amount: parseEther('0.001'), // 0.001 ETH
    to: account.address,
  });

  console.log(`L1 transaction hash: ${depositHandle.l1TxHash}`);
  console.log('Waiting for the deposit to be confirmed on L1...');

  // Wait for L1 inclusion
  const l1Receipt = await sdk.deposits.wait(depositHandle, { for: 'l1' });
  console.log(`Deposit confirmed on L1 in block ${l1Receipt?.blockNumber}`);

  console.log('Waiting for the deposit to be executed on L2...');

  // Wait for L2 execution
  const l2Receipt = await sdk.deposits.wait(depositHandle, { for: 'l2' });
  console.log(`Deposit executed on L2 in block ${l2Receipt?.blockNumber}`);
  console.log('Deposit complete! ‚úÖ');

  const L1balanceAfter = await l1.getBalance({ address: account.address });
  const L2balanceAfter = await l2.getBalance({ address: account.address });

  console.log('Wallet balance on L1 after:', L1balanceAfter);
  console.log('Wallet balance on L2 after:', L2balanceAfter);

  /*
    // OPTIONAL: ADVANCED CONTROL
    // The SDK also lets you inspect a transaction before sending it.
    // This follows the Mental Model: quote -&gt; prepare -&gt; create.
    // Uncomment the code below to see it in action.

    const params = {
      token: ETH_ADDRESS,
      amount: parseEther('0.001'),
      to: account.address,
      // Optional gas control:
      // l1TxOverrides: {
      //   gasLimit: 280_000n,
      //   maxFeePerGas: parseEther('0.00000002'),
      //   maxPriorityFeePerGas: parseEther('0.000000002'),
      // },
    };

    // Get a quote for the fees
    const quote = await sdk.deposits.quote(params);
    console.log('Fee quote:', quote);

    // Prepare the transaction without sending
    const plan = await sdk.deposits.prepare(params);
    console.log('Transaction plan:', plan);
  */
}

main().catch((error) =&gt; {
  console.error('An error occurred:', error);
  process.exit(1);
});
</code></pre>
<h2 id="4-run-the-script"><a class="header" href="#4-run-the-script">4. Run the Script</a></h2>
<pre><code class="language-bash">bun run deposit-viem.ts
# or with tsx:
# npx tsx deposit-viem.ts
</code></pre>
<p>You‚Äôll see logs for the L1 transaction, then L2 execution, and a final status snapshot.</p>
<h2 id="5-troubleshooting"><a class="header" href="#5-troubleshooting">5. Troubleshooting</a></h2>
<ul>
<li><strong>Insufficient funds on L1:</strong> Ensure enough ETH for the deposit <strong>and</strong> L1 gas.</li>
<li><strong>Invalid <code>PRIVATE_KEY</code>:</strong> Must be <code>0x</code> + 64 hex chars.</li>
<li><strong>Stuck at <code>wait(..., { for: 'l2' })</code>:</strong> Verify <code>L2_RPC_URL</code> and network health; check <code>sdk.deposits.status(handle)</code> to see the current phase.</li>
<li><strong>ERC-20 deposits:</strong> May require an L1 <code>approve()</code>; <code>quote()</code> will surface required steps.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-ethers-eth-deposit-l1--l2"><a class="header" href="#quickstart-ethers-eth-deposit-l1--l2">Quickstart (ethers): ETH Deposit (L1 ‚Üí L2)</a></h1>
<p>This guide will get you from zero to a working <strong>ETH deposit from Ethereum to ZKsync (L2)</strong> in minutes using the <strong>ethers</strong> adapter. üöÄ</p>
<p>You'll set up your environment, write a short script to make a deposit, and run it.</p>
<h2 id="1-prerequisites-1"><a class="header" href="#1-prerequisites-1">1. Prerequisites</a></h2>
<ul>
<li>You have <a href="https://bun.sh/">Bun</a> installed.</li>
<li>You have an L1 wallet (e.g., Sepolia testnet) funded with some ETH to pay for gas and the deposit.</li>
</ul>
<h2 id="2-installation--setup-1"><a class="header" href="#2-installation--setup-1">2. Installation &amp; Setup</a></h2>
<p>First, install the necessary packages.</p>
<pre><code class="language-bash">bun install @matterlabs/zksync-js ethers dotenv
</code></pre>
<p>Next, create a <code>.env</code> file in your project's root directory to store your private key and RPC endpoints. <strong>Never commit this file to Git.</strong></p>
<p><strong><code>.env</code> file:</strong></p>
<pre><code class="language-env"># Your funded L1 wallet private key (e.g., from MetaMask)
PRIVATE_KEY=0xYOUR_PRIVATE_KEY_HERE

# RPC endpoints
L1_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_ID
L2_RPC_URL="ZKSYNC-OS-TESTNET-RPC"
</code></pre>
<h2 id="3-the-deposit-script-1"><a class="header" href="#3-the-deposit-script-1">3. The Deposit Script</a></h2>
<p>The following script will connect to the networks, create a deposit transaction, send it, and wait for it to be confirmed on both L1 and L2.</p>
<p>Save this code as <code>deposit-ethers.ts</code>:</p>
<pre><code class="language-ts">import 'dotenv/config'; // Load environment variables from .env
import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient } from '@matterlabs/zksync-js/ethers';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const PRIVATE_KEY = process.env.PRIVATE_KEY;
const L1_RPC_URL = process.env.L1_RPC_URL;
const L2_RPC_URL = process.env.L2_RPC_URL;

async function main() {
  if (!PRIVATE_KEY || !L1_RPC_URL || !L2_RPC_URL) {
    throw new Error('Please set your PRIVATE_KEY, L1_RPC_URL, and L2_RPC_URL in a .env file');
  }

  // 1. SET UP PROVIDERS AND SIGNER
  // The SDK needs connections to both L1 and L2 to function.
  const l1Provider = new JsonRpcProvider(L1_RPC_URL);
  const l2Provider = new JsonRpcProvider(L2_RPC_URL);
  const signer = new Wallet(PRIVATE_KEY, l1Provider);

  // 2. INITIALIZE THE SDK CLIENT
  // The client is the low-level interface for interacting with the API.
  const client = await createEthersClient({
    l1Provider,
    l2Provider,
    signer,
  });

  const L1balance = await l1.getBalance({ address: signer.address });
  const L2balance = await l2.getBalance({ address: signer.address });

  console.log('Wallet balance on L1:', L1balance);
  console.log('Wallet balance on L2:', L2balance);

  // 3. PERFORM THE DEPOSIT
  // The create() method prepares and sends the transaction.
  // The wait() method polls until the transaction is complete.
  console.log('Sending deposit transaction...');
  const depositHandle = await sdk.deposits.create({
    token: ETH_ADDRESS,
    amount: parseEther('0.001'), // 0.001 ETH
    to: account.address,
  });

  console.log(`L1 transaction hash: ${depositHandle.l1TxHash}`);
  console.log('Waiting for the deposit to be confirmed on L1...');

  // Wait for L1 inclusion
  const l1Receipt = await sdk.deposits.wait(depositHandle, { for: 'l1' });
  console.log(`Deposit confirmed on L1 in block ${l1Receipt?.blockNumber}`);

  console.log('Waiting for the deposit to be executed on L2...');

  // Wait for L2 execution
  const l2Receipt = await sdk.deposits.wait(depositHandle, { for: 'l2' });
  console.log(`Deposit executed on L2 in block ${l2Receipt?.blockNumber}`);
  console.log('Deposit complete! ‚úÖ');

  const L1balanceAfter = await l1.getBalance({ address: signer.address });
  const L2balanceAfter = await l2.getBalance({ address: signer.address });

  console.log('Wallet balance on L1 after:', L1balanceAfter);
  console.log('Wallet balance on L2 after:', L2balanceAfter);

  /*
    // OPTIONAL: ADVANCED CONTROL
    // The SDK also lets you inspect a transaction before sending it.
    // This follows the Mental Model: quote -&gt; prepare -&gt; create.
    // Uncomment the code below to see it in action.

    const params = {
      token: ETH_ADDRESS,
      amount: parseEther('0.001'),
      to: account.address,
      // Optional: pin gas fees instead of using provider estimates
      // l1TxOverrides: {
      //   gasLimit: 280_000n,
      //   maxFeePerGas: parseEther('0.00000002'), // 20 gwei
      //   maxPriorityFeePerGas: parseEther('0.000000002'), // 2 gwei
      // },
    };

    // Get a quote for the fees
    const quote = await sdk.deposits.quote(params);
    console.log('Fee quote:', quote);

    // Prepare the transaction without sending
    const plan = await sdk.deposits.prepare(params);
    console.log('Transaction plan:', plan);
  */
}

main().catch((error) =&gt; {
  console.error('An error occurred:', error);
  process.exit(1);
});
</code></pre>
<h2 id="4-run-the-script-1"><a class="header" href="#4-run-the-script-1">4. Run the Script</a></h2>
<p>Execute the script using <code>bun</code>.</p>
<pre><code class="language-bash">bun run deposit-ethers.ts
</code></pre>
<p>You should see output confirming the L1 transaction, the wait periods, and finally the successful L2 verification.</p>
<h2 id="5-troubleshooting-1"><a class="header" href="#5-troubleshooting-1">5. Troubleshooting</a></h2>
<ul>
<li><strong>Insufficient funds on L1:</strong> Make sure your wallet has enough ETH on L1 to cover both the deposit amount (<code>0.001</code> ETH) and the L1 gas fees.</li>
<li><strong>Invalid <code>PRIVATE_KEY</code>:</strong> Ensure it‚Äôs a 64-character hex string, prefixed with <code>0x</code>.</li>
<li><strong>Stuck waiting for L2:</strong> This can take a few minutes. If it takes too long, check that your <code>L2_RPC_URL</code> is correct and the network is operational.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-guides"><a class="header" href="#how-to-guides">How-to Guides</a></h1>
<p>This section provides <strong>task-focused recipes</strong> for deposits and withdrawals with the adapter of your choice.</p>
<p>Each guide shows the minimal steps to accomplish a task using the SDK, with real code you can copy, paste, and run.</p>
<h2 id="when-to-use-guides"><a class="header" href="#when-to-use-guides">When to use Guides</a></h2>
<ul>
<li>Use these guides if you want to <strong>get something working quickly</strong> (e.g., deposit ETH, withdraw ERC-20).</li>
<li>If you need a deeper explanation of the SDK‚Äôs design, check <a href="guides/../concepts/index.html">Concepts</a>.</li>
</ul>
<h2 id="available-guides"><a class="header" href="#available-guides">Available Guides</a></h2>
<h3 id="deposits-1"><a class="header" href="#deposits-1">Deposits</a></h3>
<ul>
<li><a href="guides/./deposits/viem.html">Deposits with viem</a></li>
<li><a href="guides/./deposits/ethers.html">Deposits with ethers</a></li>
</ul>
<h3 id="withdrawals-1"><a class="header" href="#withdrawals-1">Withdrawals</a></h3>
<ul>
<li><a href="guides/./withdrawals/viem.html">Withdrawals with viem</a></li>
<li><a href="guides/./withdrawals/ethers.html">Withdrawals with ethers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposits-viem"><a class="header" href="#deposits-viem">Deposits (viem)</a></h1>
<p>A fast path to deposit <strong>ETH / ERC-20</strong> from L1 ‚Üí ZKsync (L2) using the <strong>viem</strong> adapter.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>A funded <strong>L1</strong> account (gas + amount).</li>
<li>RPC URLs: <code>L1_RPC_URL</code>, <code>L2_RPC_URL</code>.</li>
<li>Installed: <code>@matterlabs/zksync-js</code> + <code>viem</code>.</li>
</ul>
<hr />
<h2 id="parameters-quick-reference"><a class="header" href="#parameters-quick-reference">Parameters (quick reference)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Param</th><th>Required</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>token</code></td><td>Yes</td><td><code>ETH_ADDRESS</code> or ERC-20 address</td></tr>
<tr><td><code>amount</code></td><td>Yes</td><td>BigInt/wei (e.g. <code>parseEther('0.01')</code>)</td></tr>
<tr><td><code>to</code></td><td>Yes</td><td>L2 recipient address</td></tr>
<tr><td><code>l2GasLimit</code></td><td>No</td><td>L2 execution gas cap</td></tr>
<tr><td><code>gasPerPubdata</code></td><td>No</td><td>Pubdata price hint</td></tr>
<tr><td><code>operatorTip</code></td><td>No</td><td>Optional tip to operator</td></tr>
<tr><td><code>refundRecipient</code></td><td>No</td><td>L2 address to receive fee refunds</td></tr>
<tr><td><code>l1TxOverrides</code></td><td>No</td><td>L1 tx overrides (e.g. gasLimit, maxFeePerGas, maxPriorityFeePerGas)</td></tr>
</tbody></table>
</div>
<blockquote>
<p>ERC-20 deposits may require an L1 <code>approve()</code>. <strong><code>quote()</code></strong> surfaces required steps.</p>
</blockquote>
<h2 id="fast-path-one-shot"><a class="header" href="#fast-path-one-shot">Fast path (one-shot)</a></h2>
<pre><code class="language-ts">// examples/deposit-eth.ts
import { createPublicClient, createWalletClient, http, parseEther, WalletClient } from 'viem';
import type { Account, Chain, Transport } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

import { createViemSdk, createViemClient } from '@matterlabs/zksync-js/viem';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const L1_RPC = 'http://localhost:8545'; // e.g. https://sepolia.infura.io/v3/XXX
const L2_RPC = 'http://localhost:3050'; // your L2 RPC
const PRIVATE_KEY = process.env.PRIVATE_KEY || '';

async function main() {
  if (!PRIVATE_KEY || PRIVATE_KEY.length !== 66) {
    throw new Error('Set your PRIVATE_KEY in the .env file');
  }

  // --- Viem clients ---
  const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);

  const l1 = createPublicClient({ transport: http(L1_RPC) });
  const l2 = createPublicClient({ transport: http(L2_RPC) });
  const l1Wallet: WalletClient&lt;Transport, Chain, Account&gt; = createWalletClient({
    account,
    transport: http(L1_RPC),
  });

  // Check balances
  const [balL1, balL2] = await Promise.all([
    l1.getBalance({ address: account.address }),
    l2.getBalance({ address: account.address }),
  ]);
  console.log('L1 balance:', balL1.toString());
  console.log('L2 balance:', balL2.toString());

  // client + sdk
  const client = createViemClient({ l1, l2, l1Wallet });
  const sdk = createViemSdk(client);

  const me = account.address;
  const params = {
    amount: parseEther('0.01'), // 0.01 ETH
    to: me,
    token: ETH_ADDRESS,
    // optional:
    // l2GasLimit: 300_000n,
    // gasPerPubdata: 800n,
    // operatorTip: 0n,
    // refundRecipient: me,
  } as const;

  // Quote
  const quote = await sdk.deposits.quote(params);
  console.log('QUOTE response:', quote);

  // Prepare (route + steps, no sends)
  const prepared = await sdk.deposits.prepare(params);
  console.log('PREPARE response:', prepared);

  // Create (prepare + send)
  const created = await sdk.deposits.create(params);
  console.log('CREATE response:', created);

  // Status (quick check)
  const status = await sdk.deposits.status(created);
  console.log('STATUS response:', status);

  // Wait (L1 inclusion)
  const l1Receipt = await sdk.deposits.wait(created, { for: 'l1' });
  console.log(
    'L1 Included at block:',
    l1Receipt?.blockNumber,
    'status:',
    l1Receipt?.status,
    'hash:',
    l1Receipt?.transactionHash,
  );

  // Status again
  const status2 = await sdk.deposits.status(created);
  console.log('STATUS2 response:', status2);

  // Wait for L2 execution
  const l2Receipt = await sdk.deposits.wait(created, { for: 'l2' });
  console.log(
    'L2 Included at block:',
    l2Receipt?.blockNumber,
    'status:',
    l2Receipt?.status,
    'hash:',
    l2Receipt?.transactionHash,
  );
}

main().catch((e) =&gt; {
  console.error(e);
  process.exit(1);
});
</code></pre>
<ul>
<li><code>create()</code> prepares <strong>and</strong> sends.</li>
<li><code>wait(..., { for: 'l1' })</code> ‚áí included on L1.</li>
<li><code>wait(..., { for: 'l2' })</code> ‚áí executed on L2 (funds available).</li>
</ul>
<h2 id="inspect--customize-quote--prepare--create"><a class="header" href="#inspect--customize-quote--prepare--create">Inspect &amp; customize (quote ‚Üí prepare ‚Üí create)</a></h2>
<p><strong>1. Quote (no side-effects)</strong></p>
<p>Preview fees/steps and whether an approve is required.</p>
<pre><code class="language-ts">const quote = await sdk.deposits.quote(params);
</code></pre>
<p><strong>2. Prepare (build txs, don‚Äôt send)</strong>
Get <code>TransactionRequest[]</code> for signing/UX.</p>
<pre><code class="language-ts">const plan = await sdk.deposits.prepare(params);
</code></pre>
<p><strong>3. Create (send)</strong>
Use defaults, or send your prepared txs if you customized.</p>
<pre><code class="language-ts">const handle = await sdk.deposits.create(params);
</code></pre>
<h2 id="track-progress-status-vs-wait"><a class="header" href="#track-progress-status-vs-wait">Track progress (status vs wait)</a></h2>
<p><strong>Non-blocking snapshot</strong></p>
<pre><code class="language-ts">const s = await sdk.deposits.status(handle /* or l1TxHash */);
// 'UNKNOWN' | 'L1_PENDING' | 'L1_INCLUDED' | 'L2_PENDING' | 'L2_EXECUTED' | 'L2_FAILED'
</code></pre>
<p><strong>Block until checkpoint</strong></p>
<pre><code class="language-ts">const l1Receipt = await sdk.deposits.wait(handle, { for: 'l1' });
const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error handling patterns</a></h2>
<p><strong>Exceptions</strong></p>
<pre><code class="language-ts">try {
  const handle = await sdk.deposits.create(params);
} catch (e) {
  // normalized error envelope (type, operation, message, context, revert?)
}
</code></pre>
<p><strong>No-throw style</strong></p>
<p>Every method has a <code>try*</code> variant (e.g. <code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>).<br />
These never throw‚Äîso you don‚Äôt need a <code>try/catch</code>. Instead they return:</p>
<ul>
<li><code>{ ok: true, value: ... }</code> on success</li>
<li><code>{ ok: false, error: ... }</code> on failure</li>
</ul>
<p>This is useful for <strong>UI flows</strong> or <strong>services</strong> where you want explicit control over errors.</p>
<pre><code class="language-ts">const r = await sdk.deposits.tryCreate(params);

if (!r.ok) {
  // handle the error gracefully
  console.error('Deposit failed:', r.error);
  // maybe show a toast, retry, etc.
} else {
  const handle = r.value;
  console.log('Deposit sent. L1 tx hash:', handle.l1TxHash);
}
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<ul>
<li><strong>Stuck at L1:</strong> check L1 gas and RPC health.</li>
<li><strong>No L2 execution:</strong> verify L2 RPC; re-check <code>status()</code> (should move to <code>L2_EXECUTED</code>).</li>
<li><strong>L2 failed:</strong> <code>status.phase === 'L2_FAILED'</code> ‚Üí inspect revert info via your error envelope/logs.</li>
</ul>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li><a href="guides/deposits/../../concepts/status-vs-wait.html">Status vs Wait</a></li>
<li><a href="guides/deposits/../../zks/methods.html">ZKsync RPC Helpers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposits-ethers"><a class="header" href="#deposits-ethers">Deposits (ethers)</a></h1>
<p>A fast path to deposit <strong>ETH / ERC-20</strong> from L1 ‚Üí ZKsync (L2) using the <strong>ethers</strong> adapter.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>A funded <strong>L1</strong> account (gas + amount).</li>
<li>RPC URLs: <code>L1_RPC_URL</code>, <code>L2_RPC_URL</code>.</li>
<li>Installed: <code>@matterlabs/zksync-js</code> + <code>ethers</code>.</li>
</ul>
<hr />
<h2 id="parameters-quick-reference-1"><a class="header" href="#parameters-quick-reference-1">Parameters (quick reference)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Param</th><th>Required</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>token</code></td><td>Yes</td><td><code>ETH_ADDRESS</code> or ERC-20 address</td></tr>
<tr><td><code>amount</code></td><td>Yes</td><td>BigInt/wei (e.g. <code>parseEther('0.01')</code>)</td></tr>
<tr><td><code>to</code></td><td>Yes</td><td>L2 recipient address</td></tr>
<tr><td><code>l2GasLimit</code></td><td>No</td><td>L2 execution gas cap</td></tr>
<tr><td><code>gasPerPubdata</code></td><td>No</td><td>Pubdata price hint</td></tr>
<tr><td><code>operatorTip</code></td><td>No</td><td>Optional tip to operator</td></tr>
<tr><td><code>refundRecipient</code></td><td>No</td><td>L2 address to receive fee refunds</td></tr>
<tr><td><code>l1TxOverrides</code></td><td>No</td><td>L1 tx overrides (e.g. gasLimit, maxFeePerGas, maxPriorityFeePerGas)</td></tr>
</tbody></table>
</div>
<blockquote>
<p>ERC-20 deposits may require an L1 <code>approve()</code>. <strong><code>quote()</code></strong> surfaces required steps.</p>
</blockquote>
<hr />
<h2 id="fast-path-one-shot-1"><a class="header" href="#fast-path-one-shot-1">Fast path (one-shot)</a></h2>
<pre><code class="language-ts">// examples/deposit-eth.ts
import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const L1_RPC = 'http://localhost:8545'; // e.g. https://sepolia.infura.io/v3/XXX
const L2_RPC = 'http://localhost:3050'; // your L2 RPC
const PRIVATE_KEY = process.env.PRIVATE_KEY || '';

async function main() {
  if (!PRIVATE_KEY) {
    throw new Error('Set your PRIVATE_KEY in the .env file');
  }
  const l1 = new JsonRpcProvider(L1_RPC);
  const l2 = new JsonRpcProvider(L2_RPC);
  const signer = new Wallet(PRIVATE_KEY, l1);

  const balance = await l1.getBalance(signer.address);
  console.log('L1 balance:', balance.toString());

  const balanceL2 = await l2.getBalance(signer.address);
  console.log('L2 balance:', balanceL2.toString());

  const client = await createEthersClient({ l1, l2, signer });
  const sdk = createEthersSdk(client);

  const me = (await signer.getAddress());
  const params = {
    amount: parseEther('.01'), // 0.01 ETH
    to: me,
    token: ETH_ADDRESS,
    // optional:
    // l2GasLimit: 300_000n,
    // gasPerPubdata: 800n,
    // operatorTip: 0n,
    // refundRecipient: me,
  } as const;

  // Quote
  const quote = await sdk.deposits.quote(params);
  console.log('QUOTE response: ', quote);

  const prepare = await sdk.deposits.prepare(params);
  console.log('PREPARE response: ', prepare);

  // Create (prepare + send)
  const create = await sdk.deposits.create(params);
  console.log('CREATE response: ', create);

  const status = await sdk.deposits.status(create);
  console.log('STATUS response: ', status);

  // Wait (for now, L1 inclusion)
  const receipt = await sdk.deposits.wait(create, { for: 'l1' });
  console.log(
    'Included at block:',
    receipt?.blockNumber,
    'status:',
    receipt?.status,
    'hash:',
    receipt?.hash,
  );

  const status2 = await sdk.deposits.status(create);
  console.log('STATUS2 response: ', status2);

  // Wait (for now, L2 inclusion)
  const l2Receipt = await sdk.deposits.wait(create, { for: 'l2' });
  console.log(
    'Included at block:',
    l2Receipt?.blockNumber,
    'status:',
    l2Receipt?.status,
    'hash:',
    l2Receipt?.hash,
  );
}

main().catch((e) =&gt; {
  console.error(e);
  process.exit(1);
});
</code></pre>
<ul>
<li><code>create()</code> prepares <strong>and</strong> sends.</li>
<li><code>wait(..., { for: 'l1' })</code> ‚áí included on L1.</li>
<li><code>wait(..., { for: 'l2' })</code> ‚áí executed on L2 (funds available).</li>
</ul>
<h2 id="inspect--customize-quote--prepare--create-1"><a class="header" href="#inspect--customize-quote--prepare--create-1">Inspect &amp; customize (quote ‚Üí prepare ‚Üí create)</a></h2>
<p><strong>1. Quote (no side-effects)</strong>
Preview fees/steps and whether an approve is required.</p>
<pre><code class="language-ts">const quote = await sdk.deposits.quote(params);
</code></pre>
<p><strong>2. Prepare (build txs, don‚Äôt send)</strong>
Get <code>TransactionRequest[]</code> for signing/UX.</p>
<pre><code class="language-ts">const plan = await sdk.deposits.prepare(params);
</code></pre>
<p><strong>3. Create (send)</strong>
Use defaults, or send your prepared txs if you customized.</p>
<pre><code class="language-ts">const handle = await sdk.deposits.create(params);
</code></pre>
<h2 id="track-progress-status-vs-wait-1"><a class="header" href="#track-progress-status-vs-wait-1">Track progress (status vs wait)</a></h2>
<p><strong>Non-blocking snapshot</strong></p>
<pre><code class="language-ts">const s = await sdk.deposits.status(handle /* or l1TxHash */);
// 'UNKNOWN' | 'L1_PENDING' | 'L1_INCLUDED' | 'L2_PENDING' | 'L2_EXECUTED' | 'L2_FAILED'
</code></pre>
<p><strong>Block until checkpoint</strong></p>
<pre><code class="language-ts">const l1Receipt = await sdk.deposits.wait(handle, { for: 'l1' });
const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
<hr />
<h2 id="error-handling-patterns-1"><a class="header" href="#error-handling-patterns-1">Error handling patterns</a></h2>
<p><strong>Exceptions</strong></p>
<pre><code class="language-ts">try {
  const handle = await sdk.deposits.create(params);
} catch (e) {
  // normalized error envelope (type, operation, message, context, revert?)
}
</code></pre>
<p><strong>No-throw style</strong></p>
<p>Every method has a <code>try*</code> variant (e.g. <code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>).<br />
These never throw‚Äîso you don‚Äôt need a <code>try/catch</code>. Instead they return:</p>
<ul>
<li><code>{ ok: true, value: ... }</code> on success</li>
<li><code>{ ok: false, error: ... }</code> on failure</li>
</ul>
<p>This is useful for <strong>UI flows</strong> or <strong>services</strong> where you want explicit control over errors.</p>
<pre><code class="language-ts">const r = await sdk.deposits.tryCreate(params);

if (!r.ok) {
  // handle the error gracefully
  console.error('Deposit failed:', r.error);
  // maybe show a toast, retry, etc.
} else {
  const handle = r.value;
  console.log('Deposit sent. L1 tx hash:', handle.l1TxHash);
}
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<ul>
<li><strong>Stuck at L1:</strong> check L1 gas and RPC health.</li>
<li><strong>No L2 execution:</strong> verify L2 RPC; re-check <code>status()</code> (should move to <code>L2_EXECUTED</code>).</li>
<li><strong>L2 failed:</strong> <code>status.phase === 'L2_FAILED'</code> ‚Üí inspect revert info via your error envelope/logs.</li>
</ul>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<ul>
<li><a href="guides/deposits/../../concepts/status-vs-wait.html">Status vs Wait</a></li>
<li><a href="guides/deposits/../../zks/methods.html">ZKsync RPC Helpers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdrawals-viem"><a class="header" href="#withdrawals-viem">Withdrawals (viem)</a></h1>
<p>A fast path to withdraw <strong>ETH / ERC-20</strong> from ZKsync (L2) ‚Üí Ethereum (L1) using the <strong>viem</strong> adapter.</p>
<p>Withdrawals are a <strong>two-step process</strong>:</p>
<ol>
<li><strong>Initiate</strong> on L2.</li>
<li><strong>Finalize</strong> on L1 to release funds.</li>
</ol>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>A funded <strong>L2</strong> account to initiate the withdrawal.</li>
<li>A funded <strong>L1</strong> account for finalization.</li>
<li>RPC URLs: <code>L1_RPC_URL</code>, <code>L2_RPC_URL</code>.</li>
<li>Installed: <code>@matterlabs/zksync-js</code> + <code>viem</code>.</li>
</ul>
<hr />
<h2 id="parameters-quick-reference-2"><a class="header" href="#parameters-quick-reference-2">Parameters (quick reference)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Param</th><th>Required</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>token</code></td><td>Yes</td><td><code>ETH_ADDRESS</code> or ERC-20 address</td></tr>
<tr><td><code>amount</code></td><td>Yes</td><td>BigInt/wei (e.g. <code>parseEther('0.01')</code>)</td></tr>
<tr><td><code>to</code></td><td>Yes</td><td>L1 recipient address</td></tr>
<tr><td><code>refundRecipient</code></td><td>No</td><td>L2 address to receive fee refunds (if applicable)</td></tr>
<tr><td><code>l2TxOverrides</code></td><td>No</td><td>L2 tx overrides (e.g. gasLimit, maxFeePerGas, maxPriorityFeePerGas)</td></tr>
</tbody></table>
</div>
<h2 id="fast-path-one-shot-2"><a class="header" href="#fast-path-one-shot-2">Fast path (one-shot)</a></h2>
<pre><code class="language-ts">// examples/viem/withdrawals-eth.ts
import {
  createPublicClient,
  createWalletClient,
  http,
  parseEther,
  type Account,
  type Chain,
  type Transport,
} from 'viem';
import { privateKeyToAccount, nonceManager } from 'viem/accounts';

import { createViemSdk, createViemClient } from '@matterlabs/zksync-js/viem';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const L1_RPC = 'http://localhost:8545'; // e.g. https://sepolia.infura.io/v3/XXX
const L2_RPC = 'http://localhost:3050'; // your L2 RPC
const PRIVATE_KEY = process.env.PRIVATE_KEY || '';

async function main() {
  if (!PRIVATE_KEY) {
    throw new Error('Set your PRIVATE_KEY (0x-prefixed 32-byte) in env');
  }

  // --- Viem clients  ---
  const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);

  const l1 = createPublicClient({ transport: http(L1_RPC) });
  const l2 = createPublicClient({ transport: http(L2_RPC) });

  const l1Wallet = createWalletClient&lt;Transport, Chain, Account&gt;({
    account,
    transport: http(L1_RPC),
  });
  const l2Wallet = createWalletClient&lt;Transport, Chain, Account&gt;({
    account,
    transport: http(L2_RPC),
  });

  const client = createViemClient({ l1, l2, l1Wallet, l2Wallet });
  const sdk = createViemSdk(client);

  const me = account.address;

  // Withdraw ETH
  const params = {
    token: ETH_ADDRESS,
    amount: parseEther('0.01'),
    to: me,
    // l2GasLimit: 300_000n, // optional
  } as const;

  // Quote (dry run)
  const quote = await sdk.withdrawals.quote(params);
  console.log('QUOTE:', quote);

  // Prepare (no sends)
  const plan = await sdk.withdrawals.prepare(params);
  console.log('PREPARE:', plan);

  // Create (send L2 withdraw)
  const created = await sdk.withdrawals.create(params);
  console.log('CREATE:', created);

  // Quick status
  console.log('STATUS (initial):', await sdk.withdrawals.status(created.l2TxHash));

  // Wait for L2 inclusion
  const l2Receipt = await sdk.withdrawals.wait(created, { for: 'l2' });
  console.log(
    'L2 included: block=',
    l2Receipt?.blockNumber,
    'status=',
    l2Receipt?.status,
    'hash=',
    l2Receipt?.transactionHash,
  );

  // Wait until ready to finalize
  await sdk.withdrawals.wait(created.l2TxHash, { for: 'ready' });
  console.log('STATUS (ready):', await sdk.withdrawals.status(created.l2TxHash));

  // Try to finalize on L1
  const fin = await sdk.withdrawals.tryFinalize(created.l2TxHash);
  console.log('TRY FINALIZE:', fin);

  const l1Receipt = await sdk.withdrawals.wait(created.l2TxHash, { for: 'finalized' });
  if (l1Receipt) {
    console.log('L1 finalize receipt:', l1Receipt.transactionHash);
  } else {
    console.log('Finalized (no local L1 receipt ‚Äî possibly finalized by someone else).');
  }
}

main().catch((e) =&gt; {
  console.error(e);
  process.exit(1);
});
</code></pre>
<ul>
<li><code>create()</code> prepares <strong>and</strong> sends the L2 withdrawal.</li>
<li><code>wait(..., { for: 'l2' })</code> ‚áí included on L2.</li>
<li><code>wait(..., { for: 'ready' })</code> ‚áí ready for finalization.</li>
<li><code>finalize(l2TxHash)</code> ‚áí required to release funds on L1.</li>
</ul>
<h2 id="inspect--customize-quote--prepare--create-2"><a class="header" href="#inspect--customize-quote--prepare--create-2">Inspect &amp; customize (quote ‚Üí prepare ‚Üí create)</a></h2>
<p><strong>1. Quote (no side-effects)</strong></p>
<p>Preview fees/steps and whether extra approvals are required.</p>
<pre><code class="language-ts">const quote = await sdk.withdrawals.quote(params);
</code></pre>
<p><strong>2. Prepare (build txs, don‚Äôt send)</strong></p>
<p>Get <code>TransactionRequest[]</code> for signing/UX.</p>
<pre><code class="language-ts">const plan = await sdk.withdrawals.prepare(params);
</code></pre>
<p><strong>3. Create (send)</strong></p>
<p>Use defaults, or send your prepared txs if you customized.</p>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create(params);
</code></pre>
<h2 id="track-progress-status-vs-wait-2"><a class="header" href="#track-progress-status-vs-wait-2">Track progress (status vs wait)</a></h2>
<p><strong>Non-blocking snapshot</strong></p>
<pre><code class="language-ts">const s = await sdk.withdrawals.status(handle /* or l2TxHash */);
// 'UNKNOWN' | 'L2_PENDING' | 'PENDING' | 'READY_TO_FINALIZE' | 'FINALIZED'
</code></pre>
<p><strong>Block until checkpoint</strong></p>
<pre><code class="language-ts">const l2Receipt = await sdk.withdrawals.wait(handle, { for: 'l2' });
await sdk.withdrawals.wait(handle, { for: 'ready' }); // becomes finalizable
</code></pre>
<h2 id="finalization-required-step"><a class="header" href="#finalization-required-step">Finalization (required step)</a></h2>
<p>To actually release funds on L1, call <code>finalize</code>. Note
the transaction needs to be ready for finalization.</p>
<pre><code class="language-ts">const result = await sdk.withdrawals.finalize(handle.l2TxHash);
console.log('Finalization status:', result.status.phase);
</code></pre>
<h2 id="error-handling-patterns-2"><a class="header" href="#error-handling-patterns-2">Error handling patterns</a></h2>
<p><strong>Exceptions</strong></p>
<pre><code class="language-ts">try {
  const handle = await sdk.withdrawals.create(params);
} catch (e) {
  // normalized error envelope (type, operation, message, context, optional revert)
}
</code></pre>
<p><strong>No-throw style</strong></p>
<p>Every method has a <code>try*</code> variant (e.g. <code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>, <code>tryFinalize</code>).
These never throw‚Äîso you don‚Äôt need <code>try/catch</code>. Instead they return:</p>
<ul>
<li><code>{ ok: true, value: ... }</code> on success</li>
<li><code>{ ok: false, error: ... }</code> on failure</li>
</ul>
<p>This is useful for <strong>UI flows</strong> or <strong>services</strong> where you want explicit control over errors.</p>
<pre><code class="language-ts">const r = await sdk.withdrawals.tryCreate(params);

if (!r.ok) {
  console.error('Withdrawal failed:', r.error);
} else {
  const handle = r.value;
  const f = await sdk.withdrawals.tryFinalize(handle.l2TxHash);
  if (!f.ok) {
    console.error('Finalize failed:', f.error);
  } else {
    console.log('Withdrawal finalized on L1:', f.value.receipt?.transactionHash);
  }
}
</code></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<ul>
<li><strong>Never reaches READY_TO_FINALIZE:</strong> proofs may not be available yet; poll <code>status()</code> or <code>wait(..., { for: 'ready' })</code>.</li>
<li><strong>Finalize fails:</strong> ensure you have L1 gas and check revert info in the error envelope.</li>
</ul>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<ul>
<li><a href="guides/withdrawals/../../concepts/status-vs-wait.html">Status vs Wait</a></li>
<li><a href="guides/withdrawals/../../concepts/finalization.html">Finalization</a></li>
<li><a href="guides/withdrawals/../../zks/methods.html">ZKsync RPC Helpers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdrawals-ethers"><a class="header" href="#withdrawals-ethers">Withdrawals (ethers)</a></h1>
<p>A fast path to withdraw <strong>ETH / ERC-20</strong> from ZKsync (L2) ‚Üí Ethereum (L1) using the <strong>ethers</strong> adapter.</p>
<p>Withdrawals are a <strong>two-step process</strong>:</p>
<ol>
<li><strong>Initiate</strong> on L2.</li>
<li><strong>Finalize</strong> on L1 to release funds.</li>
</ol>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<ul>
<li>A funded <strong>L2</strong> account to initiate the withdrawal.</li>
<li>A funded <strong>L1</strong> account for finalization.</li>
<li>RPC URLs: <code>L1_RPC_URL</code>, <code>L2_RPC_URL</code>.</li>
<li>Installed: <code>@matterlabs/zksync-js</code> + <code>ethers</code>.</li>
</ul>
<hr />
<h2 id="parameters-quick-reference-3"><a class="header" href="#parameters-quick-reference-3">Parameters (quick reference)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Param</th><th>Required</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>token</code></td><td>Yes</td><td><code>ETH_ADDRESS</code> or ERC-20 address</td></tr>
<tr><td><code>amount</code></td><td>Yes</td><td>BigInt/wei (e.g. <code>parseEther('0.01')</code>)</td></tr>
<tr><td><code>to</code></td><td>Yes</td><td>L1 recipient address</td></tr>
<tr><td><code>refundRecipient</code></td><td>No</td><td>L2 address to receive fee refunds (if applicable)</td></tr>
<tr><td><code>l2TxOverrides</code></td><td>No</td><td>L2 tx overrides (e.g. gasLimit, maxFeePerGas, maxPriorityFeePerGas)</td></tr>
</tbody></table>
</div>
<h2 id="fast-path-one-shot-3"><a class="header" href="#fast-path-one-shot-3">Fast path (one-shot)</a></h2>
<pre><code class="language-ts">// examples/withdrawals-eth.ts
import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';
import { ETH_ADDRESS } from '@matterlabs/zksync-js/core';

const L1_RPC = 'http://localhost:8545'; // e.g. https://sepolia.infura.io/v3/XXX
const L2_RPC = 'http://localhost:3050'; // your L2 RPC
const PRIVATE_KEY = process.env.PRIVATE_KEY || '';

async function main() {
  const l1 = new JsonRpcProvider(L1_RPC);
  const l2 = new JsonRpcProvider(L2_RPC);
  const signer = new Wallet(PRIVATE_KEY, l1);

  const client = createEthersClient({ l1, l2, signer });
  const sdk = createEthersSdk(client);

  const me = (await signer.getAddress());

  // Withdraw params (ETH)
  const params = {
    token: ETH_ADDRESS,
    amount: parseEther('0.01'), // 0.001 ETH
    to: me,
    // l2GasLimit: 300_000n,
  } as const;

  // Quote (dry-run only)
  const quote = await sdk.withdrawals.quote(params);
  console.log('QUOTE: ', quote);

  const prepare = await sdk.withdrawals.prepare(params);
  console.log('PREPARE: ', prepare);

  const created = await sdk.withdrawals.create(params);
  console.log('CREATE:', created);

  // Quick status check
  console.log('STATUS (initial):', await sdk.withdrawals.status(created.l2TxHash));

  // wait for L2 inclusion
  const l2Receipt = await sdk.withdrawals.wait(created, { for: 'l2' });
  console.log(
    'L2 included: block=',
    l2Receipt?.blockNumber,
    'status=',
    l2Receipt?.status,
    'hash=',
    l2Receipt?.hash,
  );

  // Optional: check status again
  console.log('STATUS (post-L2):', await sdk.withdrawals.status(created.l2TxHash));

  // finalize on L1
  // Use tryFinalize to avoid throwing in an example script
  await sdk.withdrawals.wait(created.l2TxHash, { for: 'ready' });
  console.log('STATUS (ready):', await sdk.withdrawals.status(created.l2TxHash));

  const fin = await sdk.withdrawals.tryFinalize(created.l2TxHash);
  console.log('TRY FINALIZE: ', fin);

  const l1Receipt = await sdk.withdrawals.wait(created.l2TxHash, { for: 'finalized' });
  if (l1Receipt) {
    console.log('L1 finalize receipt:', l1Receipt.hash);
  } else {
    console.log('Finalized (no local L1 receipt available, possibly finalized by another actor).');
  }
}

main().catch((e) =&gt; {
  console.error(e);
  process.exit(1);
});
</code></pre>
<ul>
<li><code>create()</code> prepares <strong>and</strong> sends the L2 withdrawal.</li>
<li><code>wait(..., { for: 'l2' })</code> ‚áí included on L2.</li>
<li><code>wait(..., { for: 'ready' })</code> ‚áí ready for finalization.</li>
<li><code>finalize(l2TxHash)</code> ‚áí required to release funds on L1.</li>
</ul>
<h2 id="inspect--customize-quote--prepare--create-3"><a class="header" href="#inspect--customize-quote--prepare--create-3">Inspect &amp; customize (quote ‚Üí prepare ‚Üí create)</a></h2>
<p><strong>1. Quote (no side-effects)</strong></p>
<pre><code class="language-ts">const quote = await sdk.withdrawals.quote(params);
</code></pre>
<p><strong>2. Prepare (build txs, don‚Äôt send)</strong></p>
<pre><code class="language-ts">const plan = await sdk.withdrawals.prepare(params);
</code></pre>
<p><strong>3. Create (send)</strong></p>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create(params);
</code></pre>
<h2 id="track-progress-status-vs-wait-3"><a class="header" href="#track-progress-status-vs-wait-3">Track progress (status vs wait)</a></h2>
<p><strong>Non-blocking snapshot</strong></p>
<pre><code class="language-ts">const s = await sdk.withdrawals.status(handle /* or l2TxHash */);
// 'UNKNOWN' | 'L2_PENDING' | 'PENDING' | 'READY_TO_FINALIZE' | 'FINALIZED'
</code></pre>
<p><strong>Block until checkpoint</strong></p>
<pre><code class="language-ts">const l2Receipt = await sdk.withdrawals.wait(handle, { for: 'l2' });
await sdk.withdrawals.wait(handle, { for: 'ready' });
</code></pre>
<h2 id="finalization-required-step-1"><a class="header" href="#finalization-required-step-1">Finalization (required step)</a></h2>
<pre><code class="language-ts">const result = await sdk.withdrawals.finalize(handle.l2TxHash);
console.log('Finalization result:', result);
</code></pre>
<h2 id="error-handling-patterns-3"><a class="header" href="#error-handling-patterns-3">Error handling patterns</a></h2>
<p><strong>Exceptions</strong></p>
<pre><code class="language-ts">try {
  const handle = await sdk.withdrawals.create(params);
} catch (e) {
  // normalized error envelope (type, operation, message, context, optional revert)
}
</code></pre>
<p><strong>No-throw style</strong></p>
<p>Use <code>try*</code> methods to avoid exceptions. They return <code>{ ok, value }</code> or <code>{ ok, error }</code>.
Perfect for UIs or services that prefer explicit flow control.</p>
<pre><code class="language-ts">const r = await sdk.withdrawals.tryCreate(params);

if (!r.ok) {
  console.error('Withdrawal failed:', r.error);
} else {
  const handle = r.value;
  const f = await sdk.withdrawals.tryFinalize(handle.l2TxHash);
  if (!f.ok) {
    console.error('Finalize failed:', f.error);
  } else {
    console.log('Withdrawal finalized on L1:', f.value.receipt?.transactionHash);
  }
}
</code></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<ul>
<li><strong>Never reaches READY_TO_FINALIZE:</strong> proofs may not be available yet.</li>
<li><strong>Finalize reverts:</strong> ensure enough L1 gas; inspect revert info.</li>
<li><strong>Finalized but no receipt:</strong> <code>wait(..., { for: 'finalized' })</code> may return <code>null</code>; retry or rely on <code>finalize()</code> result.</li>
</ul>
<hr />
<h2 id="see-also-4"><a class="header" href="#see-also-4">See also</a></h2>
<ul>
<li><a href="guides/withdrawals/../../concepts/status-vs-wait.html">Status vs Wait</a></li>
<li><a href="guides/withdrawals/../../concepts/finalization.html">Finalization</a></li>
<li><a href="guides/withdrawals/../../zks/methods.html">ZKsync RPC Helpers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Public, typed API surface for <strong>ZKsyncOS</strong> ‚Äî <em>Incorruptible Financial Infrastructure.</em></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What Is This?</a></h2>
<p>The <strong>zksync-js</strong> provides lightweight adapters for <strong>ethers</strong> and <strong>viem</strong> to build L1 ‚Üî L2 flows ‚Äî <strong>deposits</strong> and <strong>withdrawals</strong> ‚Äî with a small, focused API. You‚Äôll work with:</p>
<ul>
<li>Adapter-level <strong>Clients</strong> (providers/wallets, resolved addresses, convenience contracts)</li>
<li>High-level <strong>SDKs</strong> (resources for deposits/withdrawals plus tokens and contracts)</li>
<li>ZKsync-specific <strong>RPC</strong> helpers (<code>client.zks.*</code>)</li>
<li>A consistent, typed <strong>Error model</strong> (<code>ZKsyncError</code>, <code>try*</code> results)</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<details>
<summary><strong>Ethers Example</strong></summary>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk, ETH_ADDRESS } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

// Low-level client + high-level SDK
const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);

// Deposit 0.05 ETH L1 ‚Üí L2 and wait for L2 execution
const handle = await sdk.deposits.create({
  token: ETH_ADDRESS,
  amount: parseEther('0.001'),
  to: await signer.getAddress(),
});

const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' });

// ZKsync-specific RPC is available via client.zks
const bridgehub = await client.zks.getBridgehubAddress();
</code></pre>
</details>
<details>
<summary><strong>Viem Example</strong></summary>
<pre><code class="language-ts">import {
  createPublicClient,
  http,
  createWalletClient,
  privateKeyToAccount,
  parseEther,
} from 'viem';
import { createViemClient, createViemSdk, ETH_ADDRESS } from '@matterlabs/zksync-js/viem';

const account = privateKeyToAccount(process.env.PRIVATE_KEY! as `0x${string}`);
const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });
const l1Wallet = createWalletClient({ account, transport: http(process.env.ETH_RPC!) });

const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);

const handle = await sdk.withdrawals.create({
  token: ETH_ADDRESS,
  amount: parseEther('0.001'),
  to: account.address, // L1 recipient
});

await sdk.withdrawals.wait(handle, { for: 'l2' }); // inclusion on L2
const { status } = await sdk.withdrawals.finalize(handle.l2TxHash); // finalize on L1

const bridgehub = await client.zks.getBridgehubAddress();
</code></pre>
</details>
<h2 id="whats-documented-here"><a class="header" href="#whats-documented-here">What's Documented Here</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Area</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="sdk-reference/./ethers/client.html"><strong>Ethers ¬∑ Client</strong></a></td><td>Low-level handle: providers/signer, resolved addresses, convenience contracts, ZK RPC access.</td></tr>
<tr><td><a href="sdk-reference/./ethers/sdk.html"><strong>Ethers ¬∑ SDK</strong></a></td><td>High-level deposits/withdrawals plus token and contract resources.</td></tr>
<tr><td><a href="sdk-reference/./ethers/contracts.html"><strong>Ethers ¬∑ Contracts</strong></a></td><td>Resolved addresses and connected core contracts.</td></tr>
<tr><td><a href="sdk-reference/./ethers/deposits.html"><strong>Ethers ¬∑ Deposits</strong></a></td><td>L1 ‚Üí L2 flow with quote, prepare, create, status, and wait.</td></tr>
<tr><td><a href="sdk-reference/./ethers/withdrawals.html"><strong>Ethers ¬∑ Withdrawals</strong></a></td><td>L2 ‚Üí L1 flow with quote, prepare, create, status, wait, and finalize.</td></tr>
<tr><td><a href="sdk-reference/./viem/client.html"><strong>Viem ¬∑ Client</strong></a></td><td><code>PublicClient</code> / <code>WalletClient</code> integration, resolved addresses, contracts, ZK RPC access.</td></tr>
<tr><td><a href="sdk-reference/./viem/sdk.html"><strong>Viem ¬∑ SDK</strong></a></td><td>Same high-level surface as ethers, typed to viem contracts.</td></tr>
<tr><td><a href="sdk-reference/./viem/contracts.html"><strong>Viem ¬∑ Contracts</strong></a></td><td>Resolved addresses and connected core contracts.</td></tr>
<tr><td><a href="sdk-reference/./viem/deposits.html"><strong>Viem ¬∑ Deposits</strong></a></td><td>L1 ‚Üí L2 flow with quote, prepare, create, status, and wait.</td></tr>
<tr><td><a href="sdk-reference/./viem/withdrawals.html"><strong>Viem ¬∑ Withdrawals</strong></a></td><td>L2 ‚Üí L1 flow with quote, prepare, create, status, wait, and finalize.</td></tr>
<tr><td><a href="sdk-reference/./core/rpc.html"><strong>Core ¬∑ ZK RPC</strong></a></td><td>ZKsync-specific RPC: <code>getBridgehubAddress</code>, <code>getBytecodeSupplierAddress</code>, <code>getBlockMetadataByNumber</code>, <code>getL2ToL1LogProof</code>.</td></tr>
<tr><td><a href="sdk-reference/./core/errors.html"><strong>Core ¬∑ Error model</strong></a></td><td>Typed <code>ZKsyncError</code> envelope and <code>try*</code> result helpers.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="notes--conventions"><a class="header" href="#notes--conventions">Notes &amp; Conventions</a></h2>
<blockquote>
<p>[!NOTE]
<strong>Standard <code>eth_*</code> RPC</strong> should always be performed through your chosen base library (<strong>ethers</strong> or <strong>viem</strong>).
The SDK only adds <strong>ZKsync-specific</strong> RPC methods via <code>client.zks.*</code> (e.g. <code>getBridgehubAddress</code>, <code>getBytecodeSupplierAddress</code>, <code>getBlockMetadataByNumber</code>, <code>getGenesis</code>).</p>
</blockquote>
<ul>
<li>Every resource method has a <strong><code>try*</code> variant</strong> (e.g. <code>tryCreate</code>) that returns a result object instead of throwing.
When errors occur, the SDK throws <strong><code>ZKsyncError</code></strong> with a stable, structured envelope (see <a href="sdk-reference/./core/errors.html">Error model</a>).</li>
<li>Address resolution comes from on-chain lookups and well-known constants, but can be overridden in the client constructor for forks/tests.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zks_-rpc"><a class="header" href="#zks_-rpc">zks_ RPC</a></h1>
<p>Public ZKsync <code>zks_*</code> RPC methods exposed on the adapters via <code>client.zks</code> (Bridgehub address, Bytecode Supplier address, block metadata, L2‚ÜíL1 log proofs, receipts with <code>l2ToL1Logs</code>).</p>
<h2 id="standard-ethereum-rpc-eth_"><a class="header" href="#standard-ethereum-rpc-eth_">Standard Ethereum RPC (<code>eth_*</code>)</a></h2>
<p>Use your base library for all <code>eth_*</code> methods.
The <code>client.zks</code> surface only covers ZKsync-specific RPC (<code>zks_*</code>).
For standard Ethereum JSON-RPC (e.g., <code>eth_call</code>, <code>eth_getLogs</code>, <code>eth_getBalance</code>), call them through your chosen library (<strong>ethers</strong> or <strong>viem</strong>).</p>
<h2 id="zks_-interface"><a class="header" href="#zks_-interface">zks_ Interface</a></h2>
<pre><code class="language-ts">interface ZksRpc {
  getBridgehubAddress(): Promise&lt;Address&gt;;
  getBytecodeSupplierAddress(): Promise&lt;Address&gt;;
  getL2ToL1LogProof(txHash: Hex, index: number): Promise&lt;ProofNormalized&gt;;
  getReceiptWithL2ToL1(txHash: Hex): Promise&lt;ReceiptWithL2ToL1 | null&gt;;
  getBlockMetadataByNumber(blockNumber: number): Promise&lt;BlockMetadata | null&gt;;
  getGenesis(): Promise&lt;GenesisInput&gt;;
}
</code></pre>
<hr />
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="getbridgehubaddress--promiseaddress"><a class="header" href="#getbridgehubaddress--promiseaddress"><code>getBridgehubAddress() ‚Üí Promise&lt;Address&gt;</code></a></h3>
<p>Fetch the on-chain <strong>Bridgehub</strong> contract address.</p>
<pre><code class="language-ts">const addr = await client.zks.getBridgehubAddress();
</code></pre>
<hr />
<h3 id="getbytecodesupplieraddress--promiseaddress"><a class="header" href="#getbytecodesupplieraddress--promiseaddress"><code>getBytecodeSupplierAddress() ‚Üí Promise&lt;Address&gt;</code></a></h3>
<p>Fetch the on-chain <strong>Bytecode Supplier</strong> contract address.</p>
<pre><code class="language-ts">const addr = await client.zks.getBytecodeSupplierAddress();
</code></pre>
<hr />
<h3 id="getl2tol1logprooftxhash-hex-index-number--promiseproofnormalized"><a class="header" href="#getl2tol1logprooftxhash-hex-index-number--promiseproofnormalized"><code>getL2ToL1LogProof(txHash: Hex, index: number) ‚Üí Promise&lt;ProofNormalized&gt;</code></a></h3>
<p>Return a normalized proof for the <strong>L2‚ÜíL1 log</strong> at <code>index</code> in <code>txHash</code>.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>txHash</code></td><td>Hex</td><td>yes</td><td>L2 transaction hash that emitted one or more L2‚ÜíL1 logs.</td></tr>
<tr><td><code>index</code></td><td>number</td><td>yes</td><td>Zero-based index of the target L2‚ÜíL1 log within the tx.</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const proof = await client.zks.getL2ToL1LogProof(l2TxHash, 0);
/*
{
  id: bigint,
  batchNumber: bigint,
  proof: Hex[]
}
*/
</code></pre>
<blockquote>
<p>[!INFO]
If a proof isn‚Äôt available yet, this method throws a typed <code>STATE</code> error.
Poll according to your app‚Äôs cadence.</p>
</blockquote>
<hr />
<h3 id="getreceiptwithl2tol1txhash-hex--promisereceiptwithl2tol1--null"><a class="header" href="#getreceiptwithl2tol1txhash-hex--promisereceiptwithl2tol1--null"><code>getReceiptWithL2ToL1(txHash: Hex) ‚Üí Promise&lt;ReceiptWithL2ToL1 | null&gt;</code></a></h3>
<p>Fetch the transaction receipt; the returned object <strong>always</strong> includes <code>l2ToL1Logs</code> (empty array if none).</p>
<pre><code class="language-ts">const rcpt = await client.zks.getReceiptWithL2ToL1(l2TxHash);
console.log(rcpt?.l2ToL1Logs); // always an array
</code></pre>
<hr />
<h3 id="getblockmetadatabynumberblocknumber-number"><a class="header" href="#getblockmetadatabynumberblocknumber-number"><code>getBlockMetadataByNumber(blockNumber: number)</code></a></h3>
<p><strong>What it does</strong>
Fetches per-block metadata used by the node (pubdata price, native price, execution version).
Returns <code>null</code> if the block metadata is unavailable.
Price fields are returned as <code>bigint</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">const meta = await client.zks.getBlockMetadataByNumber(123_456);
if (meta) {
  console.log(meta.pubdataPricePerByte, meta.nativePrice, meta.executionVersion);
}
</code></pre>
<p><strong>Returns</strong></p>
<pre><code class="language-ts">type BlockMetadata = {
  pubdataPricePerByte: bigint;
  nativePrice: bigint;
  executionVersion: number;
};
</code></pre>
<hr />
<h2 id="types-overview"><a class="header" href="#types-overview">Types (overview)</a></h2>
<pre><code class="language-ts">type ProofNormalized = {
  id: bigint;
  batchNumber: bigint;
  proof: Hex[];
};

type ReceiptWithL2ToL1 = {
  // ‚Ä¶standard receipt fields‚Ä¶
  l2ToL1Logs: unknown[];
};

type BlockMetadata = {
  pubdataPricePerByte: bigint;
  nativePrice: bigint;
  executionVersion: number;
};
</code></pre>
<hr />
<h2 id="getgenesis"><a class="header" href="#getgenesis"><code>getGenesis()</code></a></h2>
<p><strong>What it does</strong>
Retrieves the L2 genesis configuration exposed by the node, including initial contract deployments, storage patches, execution version, and the expected genesis root.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">const genesis = await client.zks.getGenesis();

for (const contract of genesis.initialContracts) {
  console.log('Contract at', contract.address, 'with bytecode', contract.bytecode);
}

console.log('Execution version:', genesis.executionVersion);
console.log('Genesis root:', genesis.genesisRoot);
</code></pre>
<p><strong>Returns</strong></p>
<pre><code class="language-ts">type GenesisInput = {
  initialContracts: {
    address: Address;
    bytecode: `0x${string}`;
  }[];
  additionalStorage: {
    key: `0x${string}`;
    value: `0x${string}`;
  }[];
  executionVersion: number;
  genesisRoot: `0x${string}`;
};
</code></pre>
<hr />
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<details>
<summary><strong>Ethers</strong></summary>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });

// Public RPC surface:
const bridgehub = await client.zks.getBridgehubAddress();
</code></pre>
</details>
<details>
<summary><strong>Viem</strong></summary>
<pre><code class="language-ts">import { createPublicClient, http } from 'viem';
import { createViemClient } from '@matterlabs/zksync-js/viem';

const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });

// Provide a WalletClient with an account for L1 operations.
const l1Wallet = /* your WalletClient w/ account */;

const client = createViemClient({ l1, l2, l1Wallet });

// Public RPC surface:
const bridgehub = await client.zks.getBridgehubAddress();
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-model"><a class="header" href="#error-model">Error Model</a></h1>
<p>Typed, structured errors with a stable envelope across <strong>viem</strong> and <strong>ethers</strong> adapters.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>All SDK operations either:</p>
<ol>
<li><strong>Throw</strong> a <code>ZKsyncError</code> whose <code>.envelope</code> gives you a structured, stable payload, or</li>
<li>Return a <strong>result object</strong> from the <code>try*</code> variants:
<code>{ ok: true, value } | { ok: false, error }</code></li>
</ol>
<p>This is consistent across both <strong>ethers</strong> and <strong>viem</strong> adapters.</p>
<blockquote>
<p>[!TIP]
Prefer the <code>try*</code> variants when you want to avoid exceptions and branch on success/failure.</p>
</blockquote>
<h2 id="what-gets-thrown"><a class="header" href="#what-gets-thrown">What Gets Thrown</a></h2>
<p>When the SDK throws, it throws an instance of <code>ZKsyncError</code>.
Use <code>isZKsyncError(e)</code> to narrow and read the <strong>error envelope</strong>.</p>
<pre><code class="language-ts">import { isZKsyncError } from '@matterlabs/zksync-js/core';

try {
  const handle = await sdk.deposits.create(params);
} catch (e) {
  if (isZKsyncError(e)) {
    const err = e; // type-narrowed
    const { type, resource, operation, message, context, revert } = err.envelope;

    switch (type) {
      case 'VALIDATION':
      case 'STATE':
        // user/action fixable (bad input, not-ready, etc.)
        break;
      case 'EXECUTION':
      case 'RPC':
        // network/tx/provider issues
        break;
    }

    console.error(JSON.stringify(err.toJSON())); // structured log
  } else {
    throw e; // non-SDK error
  }
}
</code></pre>
<h2 id="envelope-shape"><a class="header" href="#envelope-shape">Envelope Shape</a></h2>
<p><strong>Instance Type</strong></p>
<pre><code class="language-ts">'ZKsyncError'
</code></pre>
<h3 id="zksyncerrorenvelope-errorenvelope"><a class="header" href="#zksyncerrorenvelope-errorenvelope"><code>ZKsyncError.envelope: ErrorEnvelope</code></a></h3>
<pre><code class="language-ts">type ErrorEnvelope = {
  /** Resource surface that raised the error. */
  resource: 'deposits' | 'withdrawals' | 'withdrawal-finalization' | 'helpers' | 'zksrpc';

  /** Specific operation, e.g. "withdrawals.finalize" or "deposits.create". */
  operation: string;

  /** Broad category (see table below). */
  type: 'VALIDATION' | 'STATE' | 'EXECUTION' | 'RPC' | 'INTERNAL' | 'VERIFICATION' | 'CONTRACT';

  /** Stable, human-readable message for developers. */
  message: string;

  /** Optional contextual fields (tx hash, nonce, step key, etc.). */
  context?: Record&lt;string, unknown&gt;;

  /** If the error is a contract revert, adapters include decoded info when available. */
  revert?: {
    selector: `0x${string}`; // 4-byte selector
    name?: string; // Decoded Solidity error name
    args?: unknown[]; // Decoded args
    contract?: string; // Best-effort contract label
    fn?: string; // Best-effort function label
  };

  /** Originating error (provider/transport/etc.), sanitized for safe logging. */
  cause?: unknown;
};
</code></pre>
<h3 id="categories-when-to-expect-them"><a class="header" href="#categories-when-to-expect-them">Categories (When to Expect Them)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Meaning (how to react)</th></tr></thead><tbody>
<tr><td><code>VALIDATION</code></td><td>Inputs are invalid ‚Äî fix parameters and retry.</td></tr>
<tr><td><code>STATE</code></td><td>Operation not possible <strong>yet</strong> (e.g., not finalizable). Wait or change state.</td></tr>
<tr><td><code>EXECUTION</code></td><td>A send/revert happened (tx reverted or couldn‚Äôt be confirmed). Inspect <code>revert</code>/<code>cause</code>.</td></tr>
<tr><td><code>RPC</code></td><td>Provider/transport failure. Retry with backoff or check infra.</td></tr>
<tr><td><code>VERIFICATION</code></td><td>Proof/verification issue (e.g., unable to find deposit log).</td></tr>
<tr><td><code>CONTRACT</code></td><td>Contract read/encode/allowance failed. Check addresses &amp; ABI.</td></tr>
<tr><td><code>INTERNAL</code></td><td>SDK internal issue ‚Äî report with <code>operation</code> and <code>selector</code>.</td></tr>
</tbody></table>
</div>
<h2 id="result-style-try-helpers"><a class="header" href="#result-style-try-helpers">Result Style (<code>try*</code>) Helpers</a></h2>
<p>Every resource method has a <code>try*</code> sibling that never throws and returns a <code>TryResult&lt;T&gt;</code>.</p>
<pre><code class="language-ts">const res = await sdk.withdrawals.tryCreate(params);
if (!res.ok) {
  // res.error is a ZKsyncError
  console.warn(res.error.envelope.message, res.error.envelope.operation);
} else {
  console.log('l2TxHash', res.value.l2TxHash);
}
</code></pre>
<p>This is especially useful for <strong>UI flows</strong> where you want inline validation/state messages without <code>try/catch</code>.</p>
<h2 id="revert-details-when-transactions-fail"><a class="header" href="#revert-details-when-transactions-fail">Revert Details (When Transactions Fail)</a></h2>
<p>If the provider exposes revert data, the adapters decode common error types and ABIs so you can branch on them:</p>
<pre><code class="language-ts">try {
  await sdk.withdrawals.finalize(l2TxHash);
} catch (e) {
  if (isZKsyncError(e) &amp;&amp; e.envelope.revert) {
    const { selector, name, args } = e.envelope.revert;
    // e.g., name === 'InvalidProof' or 'TransferAmountExceedsBalance'
  }
}
</code></pre>
<p><strong>Notes</strong></p>
<ul>
<li>The SDK always includes the <strong>4-byte selector</strong>.</li>
<li><code>name</code> / <code>args</code> appear when decodable; coverage will expand over time.</li>
<li>A revert implying ‚Äúnot ready yet‚Äù appears as a <code>STATE</code> error with a clear message.</li>
</ul>
<h2 id="ethers--viem-examples"><a class="header" href="#ethers--viem-examples">Ethers &amp; Viem Examples</a></h2>
<details>
<summary><strong>Ethers</strong></summary>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';
import { isZKsyncError } from '@matterlabs/zksync-js/core';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);

const res = await sdk.deposits.tryCreate({ token, amount, to });
if (!res.ok) {
  console.error(res.error.envelope); // structured envelope
}
</code></pre>
</details>
<details>
<summary><strong>Viem</strong></summary>
<pre><code class="language-ts">import { createPublicClient, http, createWalletClient, privateKeyToAccount } from 'viem';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';
import { isZKsyncError } from '@matterlabs/zksync-js/core';

const account = privateKeyToAccount(process.env.PRIVATE_KEY! as `0x${string}`);
const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });
const l1Wallet = createWalletClient({ account, transport: http(process.env.ETH_RPC!) });
const l2Wallet = createWalletClient({ account, transport: http(process.env.ZKSYNC_RPC!) });

const client = createViemClient({ l1, l2, l1Wallet, l2Wallet });
const sdk = createViemSdk(client);

try {
  await sdk.withdrawals.finalize(l2TxHash);
} catch (e) {
  if (isZKsyncError(e)) {
    console.log(e.envelope.message, e.envelope.operation);
  } else {
    throw e;
  }
}
</code></pre>
</details>
<h2 id="logging--observability"><a class="header" href="#logging--observability">Logging &amp; Observability</a></h2>
<ul>
<li><code>err.toJSON()</code> ‚Üí returns a safe, structured object suitable for telemetry.</li>
<li>Logging <code>err</code> directly prints a compact summary: category, operation, context, optional revert/cause.</li>
</ul>
<blockquote>
<p>[!WARNING]
Avoid parsing <code>err.message</code> for logic ‚Äî use typed fields on <code>err.envelope</code> instead.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethersclient"><a class="header" href="#ethersclient">EthersClient</a></h1>
<p>Low-level client for the <strong>Ethers adapter</strong>.
Carries providers/signer, resolves core contract addresses, and exposes connected <code>ethers.Contract</code> instances.</p>
<hr />
<h2 id="at-a-glance"><a class="header" href="#at-a-glance">At a Glance</a></h2>
<ul>
<li><strong>Factory:</strong> <code>createEthersClient({ l1, l2, signer, overrides? }) ‚Üí EthersClient</code></li>
<li><strong>Provides:</strong> cached core <strong>addresses</strong>, connected <strong>contracts</strong>, L2-bound <strong>ZKsync RPC</strong> (<code>zks</code>), and a signer force-bound to <strong>L1</strong>.</li>
<li><strong>Usage:</strong> Create this first, then pass it into <code>createEthersSdk(client)</code>.</li>
</ul>
<h2 id="import"><a class="header" href="#import">Import</a></h2>
<pre><code class="language-ts">import { createEthersClient } from '@matterlabs/zksync-js/ethers';
</code></pre>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });

// Resolve core addresses (cached)
const addrs = await client.ensureAddresses();

// Connected contracts
const { bridgehub, l1AssetRouter } = await client.contracts();
</code></pre>
<blockquote>
<p>[!TIP]
The signer is force-bound to the <strong>L1</strong> provider so that L1 finalization flows work out of the box.</p>
</blockquote>
<h2 id="createethersclientargs--ethersclient"><a class="header" href="#createethersclientargs--ethersclient"><code>createEthersClient(args) ‚Üí EthersClient</code></a></h2>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>args.l1</code></td><td><code>ethers.AbstractProvider</code></td><td>‚úÖ</td><td>L1 provider for reads and L1 transactions.</td></tr>
<tr><td><code>args.l2</code></td><td><code>ethers.AbstractProvider</code></td><td>‚úÖ</td><td>L2 (ZKsync) provider for reads and ZK RPC.</td></tr>
<tr><td><code>args.signer</code></td><td><code>ethers.Signer</code></td><td>‚úÖ</td><td>Signer for sends. If not connected to <code>args.l1</code>, it will be automatically connected.</td></tr>
<tr><td><code>args.overrides</code></td><td><code>Partial&lt;ResolvedAddresses&gt;</code></td><td>‚ùå</td><td>Optional address overrides (forks/tests).</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>EthersClient</code></p>
<h2 id="ethersclient-interface"><a class="header" href="#ethersclient-interface">EthersClient Interface</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td><code>'ethers'</code></td><td>Adapter discriminator.</td></tr>
<tr><td><code>l1</code></td><td><code>ethers.AbstractProvider</code></td><td>Public L1 provider.</td></tr>
<tr><td><code>l2</code></td><td><code>ethers.AbstractProvider</code></td><td>Public L2 (ZKsync) provider.</td></tr>
<tr><td><code>signer</code></td><td><code>ethers.Signer</code></td><td>Signer (bound to <code>l1</code> for sends).</td></tr>
<tr><td><code>zks</code></td><td><code>ZksRpc</code></td><td>ZKsync-specific RPC surface bound to <code>l2</code>.</td></tr>
</tbody></table>
</div>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<h3 id="ensureaddresses--promiseresolvedaddresses"><a class="header" href="#ensureaddresses--promiseresolvedaddresses"><code>ensureAddresses() ‚Üí Promise&lt;ResolvedAddresses&gt;</code></a></h3>
<p>Resolve and cache core contract addresses from chain state (merges any <code>overrides</code>).</p>
<pre><code class="language-ts">const a = await client.ensureAddresses();
/*
{
  bridgehub, l1AssetRouter, l1Nullifier, l1NativeTokenVault,
  l2AssetRouter, l2NativeTokenVault, l2BaseTokenSystem
}
*/
</code></pre>
<h3 id="contracts--promise-contracts-"><a class="header" href="#contracts--promise-contracts-"><code>contracts() ‚Üí Promise&lt;{ ...contracts }&gt;</code></a></h3>
<p>Return connected <code>ethers.Contract</code> instances for all core contracts.</p>
<pre><code class="language-ts">const c = await client.contracts();
const bh = c.bridgehub;
await bh.getAddress();
</code></pre>
<h3 id="refresh-void"><a class="header" href="#refresh-void"><code>refresh(): void</code></a></h3>
<p>Clear cached addresses/contracts. Subsequent calls re-resolve.</p>
<pre><code class="language-ts">client.refresh();
await client.ensureAddresses();
</code></pre>
<h3 id="basetokenchainid-bigint--promiseaddress"><a class="header" href="#basetokenchainid-bigint--promiseaddress"><code>baseToken(chainId: bigint) ‚Üí Promise&lt;Address&gt;</code></a></h3>
<p>Return the <strong>L1 base-token address</strong> for a given L2 chain via <code>Bridgehub.baseToken(chainId)</code>.</p>
<pre><code class="language-ts">const base = await client.baseToken(324n);
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="resolvedaddresses"><a class="header" href="#resolvedaddresses"><code>ResolvedAddresses</code></a></h3>
<pre><code class="language-ts">type ResolvedAddresses = {
  bridgehub: Address;
  l1AssetRouter: Address;
  l1Nullifier: Address;
  l1NativeTokenVault: Address;
  l2AssetRouter: Address;
  l2NativeTokenVault: Address;
  l2BaseTokenSystem: Address;
};
</code></pre>
<h2 id="notes--pitfalls"><a class="header" href="#notes--pitfalls">Notes &amp; Pitfalls</a></h2>
<ul>
<li>
<p><strong>Provider roles:</strong>
<code>l1</code> handles L1 lookups and finalization sends;
<code>l2</code> handles ZKsync reads/RPC via <code>zks</code>.</p>
</li>
<li>
<p><strong>Signer binding:</strong>
The signer is always connected to <code>l1</code> to ensure L1 transactions (e.g., finalization) succeed without manual setup.</p>
</li>
<li>
<p><strong>Caching:</strong>
<code>ensureAddresses()</code> and <code>contracts()</code> are cached.
Call <code>refresh()</code> after network changes or applying new overrides.</p>
</li>
<li>
<p><strong>Overrides:</strong>
For forks or custom deployments, pass <code>overrides</code> during construction ‚Äî they merge with on-chain resolution.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="etherssdk"><a class="header" href="#etherssdk">EthersSdk</a></h1>
<p>High-level SDK built on top of the <strong>Ethers adapter</strong> ‚Äî provides deposits, withdrawals, and token/contract resources.</p>
<hr />
<h2 id="at-a-glance-1"><a class="header" href="#at-a-glance-1">At a Glance</a></h2>
<ul>
<li><strong>Factory:</strong> <code>createEthersSdk(client) ‚Üí EthersSdk</code></li>
<li><strong>Composed resources:</strong> <code>sdk.deposits</code>, <code>sdk.withdrawals</code>, <code>sdk.tokens</code>, <code>sdk.contracts</code></li>
<li><strong>Client vs SDK:</strong> The <strong>client</strong> wires RPC/signing, while the <strong>SDK</strong> adds high-level flows (<code>quote ‚Üí prepare ‚Üí create ‚Üí wait</code>) plus token and contract resources.</li>
</ul>
<h2 id="import-1"><a class="header" href="#import-1">Import</a></h2>
<pre><code class="language-ts">import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';
</code></pre>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);

// Example: deposit 0.05 ETH L1 ‚Üí L2 and wait for L2 execution
const handle = await sdk.deposits.create({
  token: ETH_ADDRESS, // 0x‚Ä¶00 sentinel for ETH supported
  amount: parseEther('0.05'),
  to: await signer.getAddress(),
});

await sdk.deposits.wait(handle, { for: 'l2' });

// Example: resolve core contracts
const { l1NativeTokenVault } = await sdk.contracts.instances();

// Example: map a token L1 ‚Üí L2
const token = await sdk.tokens.resolve('0xYourToken');
console.log(token.l2);
</code></pre>
<blockquote>
<p>[!TIP]
The SDK composes the client with resources: <code>deposits</code>, <code>withdrawals</code>, <code>tokens</code>, and <code>contracts</code>.</p>
</blockquote>
<h2 id="createetherssdkclient--etherssdk"><a class="header" href="#createetherssdkclient--etherssdk"><code>createEthersSdk(client) ‚Üí EthersSdk</code></a></h2>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><code>EthersClient</code></td><td>‚úÖ</td><td>Instance returned by <code>createEthersClient({ l1, l2, signer })</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>EthersSdk</code></p>
<h2 id="etherssdk-interface"><a class="header" href="#etherssdk-interface">EthersSdk Interface</a></h2>
<h3 id="deposits-depositsresource"><a class="header" href="#deposits-depositsresource"><code>deposits: DepositsResource</code></a></h3>
<p>L1 ‚Üí L2 flows.
See <a href="sdk-reference/ethers/./deposits.html">Deposits</a>.</p>
<h3 id="withdrawals-withdrawalsresource"><a class="header" href="#withdrawals-withdrawalsresource"><code>withdrawals: WithdrawalsResource</code></a></h3>
<p>L2 ‚Üí L1 flows.
See <a href="sdk-reference/ethers/./withdrawals.html">Withdrawals</a>.</p>
<h3 id="tokens-tokensresource"><a class="header" href="#tokens-tokensresource"><code>tokens: TokensResource</code></a></h3>
<p>Token identity, L1‚áÑL2 mapping, bridge asset IDs, chain token facts.
See <a href="sdk-reference/ethers/./tokens.html">Tokens</a>.</p>
<h3 id="contracts-contractsresource"><a class="header" href="#contracts-contractsresource"><code>contracts: ContractsResource</code></a></h3>
<p>Resolved addresses and connected contract instances.
See <a href="sdk-reference/ethers/./contracts.html">Contracts</a>.</p>
<h2 id="contracts"><a class="header" href="#contracts"><code>contracts</code></a></h2>
<p>Utilities for resolved addresses and connected contracts. Token mapping lives in <code>sdk.tokens</code>.</p>
<h3 id="addresses--promiseresolvedaddresses"><a class="header" href="#addresses--promiseresolvedaddresses"><code>addresses() ‚Üí Promise&lt;ResolvedAddresses&gt;</code></a></h3>
<p>Resolve core addresses (Bridgehub, routers, vaults, base-token system).</p>
<pre><code class="language-ts">const a = await sdk.contracts.addresses();
</code></pre>
<h3 id="instances--promise-contracts-"><a class="header" href="#instances--promise-contracts-"><code>instances() ‚Üí Promise&lt;{ ...contracts }&gt;</code></a></h3>
<p>Return connected <code>ethers.Contract</code> instances for all core contracts.</p>
<pre><code class="language-ts">const c = await sdk.contracts.instances();
</code></pre>
<h3 id="one-off-contract-getters"><a class="header" href="#one-off-contract-getters">One-off Contract Getters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bridgehub()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected Bridgehub contract.</td></tr>
<tr><td><code>l1AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Asset Router contract.</td></tr>
<tr><td><code>l1NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Native Token Vault.</td></tr>
<tr><td><code>l1Nullifier()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Nullifier contract.</td></tr>
<tr><td><code>l2AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Asset Router contract.</td></tr>
<tr><td><code>l2NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Native Token Vault.</td></tr>
<tr><td><code>l2BaseTokenSystem()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Base Token System.</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const nullifier = await sdk.contracts.l1Nullifier();
</code></pre>
<h2 id="notes--pitfalls-1"><a class="header" href="#notes--pitfalls-1">Notes &amp; Pitfalls</a></h2>
<ul>
<li>
<p><strong>Client first:</strong>
Always construct the <strong>client</strong> with <code>{ l1, l2, signer }</code> before creating the SDK.</p>
</li>
<li>
<p><strong>Chain-derived behavior:</strong>
Contracts and token methods pull from on-chain data ‚Äî results vary by network.</p>
</li>
<li>
<p><strong>Error model:</strong>
All resource methods throw typed errors. Prefer <code>try*</code> variants (e.g., <code>tryCreate</code>) for structured results.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contracts-1"><a class="header" href="#contracts-1">Contracts</a></h1>
<p>Resolved addresses and connected core contracts for the Ethers adapter.</p>
<hr />
<h2 id="at-a-glance-2"><a class="header" href="#at-a-glance-2">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.contracts</code></li>
<li><strong>Capabilities:</strong> resolve core contract addresses, return connected <code>ethers.Contract</code> instances, per-contract getters.</li>
<li><strong>Caching:</strong> addresses and instances are memoized by the client; call <code>client.refresh()</code> to re-resolve.</li>
</ul>
<h2 id="import-2"><a class="header" href="#import-2">Import</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);
// sdk.contracts ‚Üí ContractsResource
</code></pre>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick Start</a></h2>
<p>Resolve addresses and contract handles:</p>
<pre><code class="language-ts">const addresses = await sdk.contracts.addresses();
const { l1NativeTokenVault, l2AssetRouter } = await sdk.contracts.instances();

const ntv = await sdk.contracts.l1NativeTokenVault();
</code></pre>
<h2 id="method-reference"><a class="header" href="#method-reference">Method Reference</a></h2>
<h3 id="addresses--promiseresolvedaddresses-1"><a class="header" href="#addresses--promiseresolvedaddresses-1"><code>addresses() ‚Üí Promise&lt;ResolvedAddresses&gt;</code></a></h3>
<p>Resolve core addresses (Bridgehub, routers, vaults, base-token system).</p>
<pre><code class="language-ts">const a = await sdk.contracts.addresses();
/*
{
  bridgehub,
  l1AssetRouter,
  l1Nullifier,
  l1NativeTokenVault,
  l2AssetRouter,
  l2NativeTokenVault,
  l2BaseTokenSystem
}
*/
</code></pre>
<h3 id="instances--promise-contracts--1"><a class="header" href="#instances--promise-contracts--1"><code>instances() ‚Üí Promise&lt;{ ...contracts }&gt;</code></a></h3>
<p>Return connected <code>ethers.Contract</code> instances for all core contracts.</p>
<pre><code class="language-ts">const c = await sdk.contracts.instances();
/*
{
  bridgehub,
  l1AssetRouter,
  l1Nullifier,
  l1NativeTokenVault,
  l2AssetRouter,
  l2NativeTokenVault,
  l2BaseTokenSystem
}
*/
</code></pre>
<h3 id="one-off-contract-getters-1"><a class="header" href="#one-off-contract-getters-1">One-off Contract Getters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bridgehub()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected Bridgehub contract.</td></tr>
<tr><td><code>l1AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Asset Router contract.</td></tr>
<tr><td><code>l1NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Native Token Vault.</td></tr>
<tr><td><code>l1Nullifier()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Nullifier contract.</td></tr>
<tr><td><code>l2AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Asset Router contract.</td></tr>
<tr><td><code>l2NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Native Token Vault.</td></tr>
<tr><td><code>l2BaseTokenSystem()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Base Token System.</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const router = await sdk.contracts.l2AssetRouter();
</code></pre>
<h2 id="notes--pitfalls-2"><a class="header" href="#notes--pitfalls-2">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Caching:</strong> <code>addresses()</code> and <code>instances()</code> are cached by the client; call <code>client.refresh()</code> to force re-resolution.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposits-2"><a class="header" href="#deposits-2">Deposits</a></h1>
<p>L1 ‚Üí L2 deposits for ETH and ERC-20 tokens with quote, prepare, create, status, and wait helpers.</p>
<hr />
<h2 id="at-a-glance-3"><a class="header" href="#at-a-glance-3">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.deposits</code></li>
<li><strong>Typical flow:</strong> <code>quote ‚Üí create ‚Üí wait({ for: 'l2' })</code></li>
<li><strong>Auto-routing:</strong> ETH vs ERC-20 and base-token vs non-base handled automatically</li>
<li><strong>Error style:</strong> Throwing methods (<code>quote</code>, <code>prepare</code>, <code>create</code>, <code>wait</code>) + safe variants (<code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>, <code>tryWait</code>)</li>
<li><strong>Token mapping:</strong> Use <code>sdk.tokens</code> for L1‚áÑL2 token lookups and assetIds before calling into deposits if you need token metadata.</li>
</ul>
<h2 id="import-3"><a class="header" href="#import-3">Import</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);
// sdk.deposits ‚Üí DepositsResource
</code></pre>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick Start</a></h2>
<p>Deposit <strong>0.1 ETH</strong> from L1 ‚Üí L2 and wait for <strong>L2 execution</strong>:</p>
<pre><code class="language-ts">const handle = await sdk.deposits.create({
  token: ETH_ADDRESS, // 0x‚Ä¶00 for ETH
  amount: parseEther('0.1'),
  to: await signer.getAddress(),
});

const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' }); // null only if no L1 hash
</code></pre>
<blockquote>
<p>[!TIP]
For UX that never throws, use the <code>try*</code> variants and branch on <code>ok</code>.</p>
</blockquote>
<h2 id="route-selection-automatic"><a class="header" href="#route-selection-automatic">Route Selection (Automatic)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Route</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>eth-base</code></td><td>ETH when L2 base token <strong>is ETH</strong></td></tr>
<tr><td><code>eth-nonbase</code></td><td>ETH when L2 base token <strong>‚â† ETH</strong></td></tr>
<tr><td><code>erc20-base</code></td><td>ERC-20 that <strong>is</strong> the L2 base token</td></tr>
<tr><td><code>erc20-nonbase</code></td><td>ERC-20 that <strong>is not</strong> the L2 base token</td></tr>
</tbody></table>
</div>
<p>You <strong>don‚Äôt</strong> pass a route manually; it‚Äôs derived from network metadata and the token.</p>
<h2 id="method-reference-1"><a class="header" href="#method-reference-1">Method Reference</a></h2>
<h3 id="quotep-depositparams--promisedepositquote"><a class="header" href="#quotep-depositparams--promisedepositquote"><code>quote(p: DepositParams) ‚Üí Promise&lt;DepositQuote&gt;</code></a></h3>
<p>Estimate the operation (route, approvals, gas hints). Does <strong>not</strong> send transactions.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L1 token address. Use <code>0x‚Ä¶00</code> for ETH.</td></tr>
<tr><td><code>amount</code></td><td><code>bigint</code></td><td>‚úÖ</td><td>Amount in wei to deposit.</td></tr>
<tr><td><code>to</code></td><td><code>Address</code></td><td>‚ùå</td><td>L2 recipient address. Defaults to the signer‚Äôs address if omitted.</td></tr>
<tr><td><code>refundRecipient</code></td><td><code>Address</code></td><td>‚ùå</td><td>Optional address on L1 to receive refunds for unspent gas.</td></tr>
<tr><td><code>l2GasLimit</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional manual L2 gas limit override.</td></tr>
<tr><td><code>gasPerPubdata</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional custom gas-per-pubdata value.</td></tr>
<tr><td><code>operatorTip</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional operator tip (in wei) for priority execution.</td></tr>
<tr><td><code>l1TxOverrides</code></td><td><a href="sdk-reference/ethers/deposits.html#eip1559gasoverrides"><code>Eip1559GasOverrides</code></a></td><td>‚ùå</td><td>Optional EIP-1559 gas settings for the L1 transaction.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>DepositQuote</code></p>
<pre><code class="language-ts">const q = await sdk.deposits.quote({
  token: ETH_L1,
  amount: parseEther('0.25'),
  to: await signer.getAddress(),
});
/*
{
  route: "eth-base" | "eth-nonbase" | "erc20-base" | "erc20-nonbase",
  summary: {
    route,
    approvalsNeeded: [{ token, spender, amount }],
    amounts: {
      transfer: { token, amount }
    },
    fees: {
      token,
      maxTotal,
      mintValue,
      l1: { gasLimit, maxFeePerGas, maxPriorityFeePerGas, maxTotal },
      l2: { total, baseCost, operatorTip, gasLimit, maxFeePerGas, maxPriorityFeePerGas, gasPerPubdata }
    },
    baseCost,
    mintValue
  }
}
*/
</code></pre>
<blockquote>
<p>[!TIP]
If <code>summary.approvalsNeeded</code> is non-empty (ERC-20), <code>create()</code> will include those approval steps automatically.</p>
</blockquote>
<h3 id="tryquotep--promise-ok-true-value-depositquote----ok-false-error-"><a class="header" href="#tryquotep--promise-ok-true-value-depositquote----ok-false-error-"><code>tryQuote(p) ‚Üí Promise&lt;{ ok: true; value: DepositQuote } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style version of <code>quote</code>.</p>
<h3 id="preparep-depositparams--promisedepositplantransactionrequest"><a class="header" href="#preparep-depositparams--promisedepositplantransactionrequest"><code>prepare(p: DepositParams) ‚Üí Promise&lt;DepositPlan&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Build the plan (ordered steps + unsigned transactions) without sending.</p>
<p><strong>Returns:</strong> <code>DepositPlan</code></p>
<pre><code class="language-ts">const plan = await sdk.deposits.prepare({ token: ETH_L1, amount: parseEther('0.05'), to });
/*
{
  route,
  summary: DepositQuote,
  steps: [
    { key: "approve:USDC", kind: "approve", tx: TransactionRequest },
    { key: "bridge", kind: "bridge", tx: TransactionRequest }
  ]
}
*/
</code></pre>
<h3 id="trypreparep--promise-ok-true-value-depositplan----ok-false-error-"><a class="header" href="#trypreparep--promise-ok-true-value-depositplan----ok-false-error-"><code>tryPrepare(p) ‚Üí Promise&lt;{ ok: true; value: DepositPlan } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>prepare</code>.</p>
<h3 id="createp-depositparams--promisedeposithandletransactionrequest"><a class="header" href="#createp-depositparams--promisedeposithandletransactionrequest"><code>create(p: DepositParams) ‚Üí Promise&lt;DepositHandle&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Prepares and <strong>executes</strong> all required L1 steps.
Returns a handle with the L1 transaction hash and per-step hashes.</p>
<p><strong>Returns:</strong> <code>DepositHandle</code></p>
<pre><code class="language-ts">const handle = await sdk.deposits.create({ token, amount, to });
/*
{
  kind: "deposit",
  l1TxHash: Hex,
  stepHashes: Record&lt;string, Hex&gt;,
  plan: DepositPlan
}
*/
</code></pre>
<blockquote>
<p>[!WARNING]
If any step reverts, <code>create()</code> throws a typed error.
Prefer <code>tryCreate()</code> to avoid exceptions.</p>
</blockquote>
<h3 id="trycreatep--promise-ok-true-value-deposithandle----ok-false-error-"><a class="header" href="#trycreatep--promise-ok-true-value-deposithandle----ok-false-error-"><code>tryCreate(p) ‚Üí Promise&lt;{ ok: true; value: DepositHandle } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>create</code>.</p>
<h3 id="statushandleorhash--promisedepositstatus"><a class="header" href="#statushandleorhash--promisedepositstatus"><code>status(handleOrHash) ‚Üí Promise&lt;DepositStatus&gt;</code></a></h3>
<p>Resolve the current phase for a deposit.
Accepts either the <code>DepositHandle</code> from <code>create()</code> or a raw L1 transaction hash.</p>
<p><strong>Phases</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>No L1 hash provided</td></tr>
<tr><td><code>L1_PENDING</code></td><td>L1 receipt not yet found</td></tr>
<tr><td><code>L1_INCLUDED</code></td><td>Included on L1; L2 hash not derivable yet</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 hash known; waiting for L2 receipt</td></tr>
<tr><td><code>L2_EXECUTED</code></td><td>L2 receipt found with <code>status === 1</code></td></tr>
<tr><td><code>L2_FAILED</code></td><td>L2 receipt found with <code>status !== 1</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const s = await sdk.deposits.status(handle);
// { phase, l1TxHash, l2TxHash? }
</code></pre>
<h3 id="waithandleorhash--for-l1--l2---promisetransactionreceipt--null"><a class="header" href="#waithandleorhash--for-l1--l2---promisetransactionreceipt--null"><code>wait(handleOrHash, { for: 'l1' | 'l2' }) ‚Üí Promise&lt;TransactionReceipt | null&gt;</code></a></h3>
<p>Block until the specified checkpoint.</p>
<ul>
<li><code>{ for: 'l1' }</code> ‚Üí L1 receipt (or <code>null</code> if no L1 hash)</li>
<li><code>{ for: 'l2' }</code> ‚Üí L2 receipt after canonical execution (or <code>null</code> if no L1 hash)</li>
</ul>
<pre><code class="language-ts">const l1Receipt = await sdk.deposits.wait(handle, { for: 'l1' });
const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
<h3 id="trywaithandleorhash-opts--resulttransactionreceipt"><a class="header" href="#trywaithandleorhash-opts--resulttransactionreceipt"><code>tryWait(handleOrHash, opts) ‚Üí Result&lt;TransactionReceipt&gt;</code></a></h3>
<p>Result-style <code>wait</code>.</p>
<h2 id="end-to-end-examples"><a class="header" href="#end-to-end-examples">End-to-End Examples</a></h2>
<h3 id="eth-deposit-typical"><a class="header" href="#eth-deposit-typical">ETH Deposit (Typical)</a></h3>
<pre><code class="language-ts">const handle = await sdk.deposits.create({
  token: ETH_ADDRESS,
  amount: parseEther('0.001'),
  to: await signer.getAddress(),
});

await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
<h3 id="erc-20-deposit"><a class="header" href="#erc-20-deposit">ERC-20 Deposit</a></h3>
<pre><code class="language-ts">const handle = await sdk.deposits.create({
  token: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // Example: USDC
  amount: 1_000_000n, // 1.0 USDC (6 decimals)
  to: await signer.getAddress(),
});

const l1Receipt = await sdk.deposits.wait(handle, { for: 'l1' });
</code></pre>
<hr />
<h2 id="types-overview-1"><a class="header" href="#types-overview-1">Types (Overview)</a></h2>
<pre><code class="language-ts">type DepositParams = {
  token: Address; // 0x‚Ä¶00 for ETH
  amount: bigint; // wei
  to?: Address; // L2 recipient
  refundRecipient?: Address;
  l2GasLimit?: bigint;
  gasPerPubdata?: bigint;
  operatorTip?: bigint;
  l1TxOverrides?: Eip1559GasOverrides;
};

type Eip1559GasOverrides = {
  gasLimit?: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
};

type DepositQuote = {
  route: 'eth-base' | 'eth-nonbase' | 'erc20-base' | 'erc20-nonbase';
  summary: {
    route: 'eth-base' | 'eth-nonbase' | 'erc20-base' | 'erc20-nonbase';
    approvalsNeeded: Array&lt;{ token: Address; spender: Address; amount: bigint }&gt;;
    amounts: {
      transfer: {
        token: Address;
        amount: bigint;
      };
    };
    fees: {
      token: Address;
      maxTotal: bigint;
      mintValue: bigint;
      l1: {
        gasLimit: bigint;
        maxFeePerGas: bigint;
        maxPriorityFeePerGas: bigint;
        maxTotal: bigint;
      };
      l2: {
        total: bigint;
        baseCost: bigint;
        operatorTip: bigint;
        gasLimit: bigint;
        maxFeePerGas: bigint;
        maxPriorityFeePerGas: bigint;
        gasPerPubdata: bigint;
      };
    };
    baseCost: bigint;
    mintValue: bigint;
  };
};

type DepositPlan&lt;TTx = TransactionRequest&gt; = {
  route: DepositQuote['route'];
  summary: DepositQuote;
  steps: Array&lt;{ key: string; kind: string; tx: TTx }&gt;;
};

type DepositHandle&lt;TTx = TransactionRequest&gt; = {
  kind: 'deposit';
  l1TxHash: Hex;
  stepHashes: Record&lt;string, Hex&gt;;
  plan: DepositPlan&lt;TTx&gt;;
};

type DepositStatus =
  | { phase: 'UNKNOWN'; l1TxHash: Hex }
  | { phase: 'L1_PENDING'; l1TxHash: Hex }
  | { phase: 'L1_INCLUDED'; l1TxHash: Hex }
  | { phase: 'L2_PENDING'; l1TxHash: Hex; l2TxHash: Hex }
  | { phase: 'L2_EXECUTED'; l1TxHash: Hex; l2TxHash: Hex }
  | { phase: 'L2_FAILED'; l1TxHash: Hex; l2TxHash: Hex };
</code></pre>
<blockquote>
<p>[!TIP]
Prefer the <code>try*</code> variants if you want to avoid exceptions and work with structured result objects.</p>
</blockquote>
<hr />
<h2 id="notes--pitfalls-3"><a class="header" href="#notes--pitfalls-3">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>ETH sentinel:</strong> Use the canonical <code>0x‚Ä¶00</code> address when passing ETH as <code>token</code>.</li>
<li><strong>Receipt timing:</strong> <code>wait({ for: 'l2' })</code> resolves only after canonical L2 execution ‚Äî it can take longer than L1 inclusion.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdrawals-2"><a class="header" href="#withdrawals-2">Withdrawals</a></h1>
<p>L2 ‚Üí L1 withdrawals for ETH and ERC-20 tokens with quote, prepare, create, status, wait, and finalize helpers.</p>
<hr />
<h2 id="at-a-glance-4"><a class="header" href="#at-a-glance-4">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.withdrawals</code></li>
<li><strong>Typical flow:</strong> <code>quote ‚Üí create ‚Üí wait({ for: 'l2' }) ‚Üí wait({ for: 'ready' }) ‚Üí finalize</code></li>
<li><strong>Auto-routing:</strong> ETH vs ERC-20 and base-token vs non-base handled internally</li>
<li><strong>Error style:</strong> Throwing methods (<code>quote</code>, <code>prepare</code>, <code>create</code>, <code>status</code>, <code>wait</code>, <code>finalize</code>) + safe variants (<code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>, <code>tryWait</code>, <code>tryFinalize</code>)</li>
<li><strong>Token mapping:</strong> Use <code>sdk.tokens</code> if you need L1/L2 token addresses or assetIds ahead of time.</li>
</ul>
<h2 id="import-4"><a class="header" href="#import-4">Import</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet, parseEther } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);
// sdk.withdrawals ‚Üí WithdrawalsResource
</code></pre>
<h2 id="quick-start-5"><a class="header" href="#quick-start-5">Quick Start</a></h2>
<p>Withdraw <strong>0.1 ETH</strong> from L2 ‚Üí L1 and finalize on L1:</p>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create({
  token: ETH_ADDRESS, // ETH sentinel supported
  amount: parseEther('0.1'),
  to: await signer.getAddress(), // L1 recipient
});

// 1) L2 inclusion (adds l2ToL1Logs if available)
await sdk.withdrawals.wait(handle, { for: 'l2' });

// 2) Wait until finalizable (no side effects)
await sdk.withdrawals.wait(handle, { for: 'ready', pollMs: 6000 });

// 3) Finalize on L1 (no-op if already finalized)
const { status, receipt: l1Receipt } = await sdk.withdrawals.finalize(handle.l2TxHash);
</code></pre>
<blockquote>
<p>[!INFO]
Withdrawals are two-phase: inclusion on <strong>L2</strong>, then <strong>finalization on L1</strong>.
You can call <code>finalize</code> directly; it will throw if not yet ready.
Prefer <code>wait(..., { for: 'ready' })</code> to avoid that.</p>
</blockquote>
<h2 id="route-selection-automatic-1"><a class="header" href="#route-selection-automatic-1">Route Selection (Automatic)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Route</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>base</code></td><td>Withdrawing the <strong>base token</strong> (ETH or otherwise)</td></tr>
<tr><td><code>erc20-nonbase</code></td><td>Withdrawing an ERC-20 that is <strong>not</strong> the base token</td></tr>
</tbody></table>
</div>
<p>You <strong>don‚Äôt</strong> pass a route manually; it‚Äôs derived from network metadata and the token.</p>
<h2 id="method-reference-2"><a class="header" href="#method-reference-2">Method Reference</a></h2>
<h3 id="quotep-withdrawparams--promisewithdrawquote"><a class="header" href="#quotep-withdrawparams--promisewithdrawquote"><code>quote(p: WithdrawParams) ‚Üí Promise&lt;WithdrawQuote&gt;</code></a></h3>
<p>Estimate the operation (route, approvals, gas hints). Does <strong>not</strong> send transactions.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L2 token (ETH sentinel supported).</td></tr>
<tr><td><code>amount</code></td><td><code>bigint</code></td><td>‚úÖ</td><td>Amount in wei to withdraw.</td></tr>
<tr><td><code>to</code></td><td><code>Address</code></td><td>‚ùå</td><td>L1 recipient. Defaults to the signer‚Äôs address.</td></tr>
<tr><td><code>l2GasLimit</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional custom gas limit override for the L2 withdrawal transaction.</td></tr>
<tr><td><code>l2TxOverrides</code></td><td><a href="sdk-reference/ethers/withdrawals.html#eip1559gasoverrides"><code>Eip1559GasOverrides</code></a></td><td>‚ùå</td><td>Optional EIP-1559 overrides for the L2 withdrawal transaction.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>WithdrawQuote</code></p>
<pre><code class="language-ts">const q = await sdk.withdrawals.quote({ token, amount, to });
/*
{
  route: "base" | "erc20-nonbase",
  summary: {
    route,
    approvalsNeeded: [{ token, spender, amount }],
    amounts: {
      transfer: { token, amount }
    },
    fees: {
      token,
      maxTotal,
      mintValue,
      l2: { gasLimit, maxFeePerGas, maxPriorityFeePerGas, total }
    }
  }
}
*/
</code></pre>
<h3 id="tryquotep--promise-ok-true-value-withdrawquote----ok-false-error-"><a class="header" href="#tryquotep--promise-ok-true-value-withdrawquote----ok-false-error-"><code>tryQuote(p) ‚Üí Promise&lt;{ ok: true; value: WithdrawQuote } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>quote</code>.</p>
<h3 id="preparep-withdrawparams--promisewithdrawplantransactionrequest"><a class="header" href="#preparep-withdrawparams--promisewithdrawplantransactionrequest"><code>prepare(p: WithdrawParams) ‚Üí Promise&lt;WithdrawPlan&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Build the plan (ordered L2 steps + unsigned transactions) without sending.</p>
<p><strong>Returns:</strong> <code>WithdrawPlan</code></p>
<pre><code class="language-ts">const plan = await sdk.withdrawals.prepare({ token, amount, to });
/*
{
  route,
  summary: WithdrawQuote,
  steps: [
    { key, kind, tx: TransactionRequest },
    // ‚Ä¶
  ]
}
*/
</code></pre>
<h3 id="trypreparep--promise-ok-true-value-withdrawplan----ok-false-error-"><a class="header" href="#trypreparep--promise-ok-true-value-withdrawplan----ok-false-error-"><code>tryPrepare(p) ‚Üí Promise&lt;{ ok: true; value: WithdrawPlan } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>prepare</code>.</p>
<h3 id="createp-withdrawparams--promisewithdrawhandletransactionrequest"><a class="header" href="#createp-withdrawparams--promisewithdrawhandletransactionrequest"><code>create(p: WithdrawParams) ‚Üí Promise&lt;WithdrawHandle&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Prepares and <strong>executes</strong> all required <strong>L2</strong> steps.
Returns a handle containing the <strong>L2 transaction hash</strong>.</p>
<p><strong>Returns:</strong> <code>WithdrawHandle</code></p>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create({ token, amount, to });
/*
{
  kind: "withdrawal",
  l2TxHash: Hex,
  stepHashes: Record&lt;string, Hex&gt;,
  plan: WithdrawPlan
}
*/
</code></pre>
<blockquote>
<p>[!WARNING]
If any L2 step reverts, <code>create()</code> throws a typed error.
Prefer <code>tryCreate()</code> to avoid exceptions.</p>
</blockquote>
<h3 id="trycreatep--promise-ok-true-value-withdrawhandle----ok-false-error-"><a class="header" href="#trycreatep--promise-ok-true-value-withdrawhandle----ok-false-error-"><code>tryCreate(p) ‚Üí Promise&lt;{ ok: true; value: WithdrawHandle } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>create</code>.</p>
<h3 id="statushandleorhash--promisewithdrawalstatus"><a class="header" href="#statushandleorhash--promisewithdrawalstatus"><code>status(handleOrHash) ‚Üí Promise&lt;WithdrawalStatus&gt;</code></a></h3>
<p>Return the current phase of a withdrawal.
Accepts either a <code>WithdrawHandle</code> or a raw <strong>L2 transaction hash</strong>.</p>
<p><strong>Phases</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>No L2 hash provided</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 receipt missing</td></tr>
<tr><td><code>PENDING</code></td><td>Included on L2 but not yet finalizable</td></tr>
<tr><td><code>READY_TO_FINALIZE</code></td><td>Can be finalized on L1 now</td></tr>
<tr><td><code>FINALIZED</code></td><td>Already finalized on L1</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const s = await sdk.withdrawals.status(handle);
// { phase, l2TxHash, key? }
</code></pre>
<h3 id="waithandleorhash--for-l2--ready--finalized-pollms-timeoutms-"><a class="header" href="#waithandleorhash--for-l2--ready--finalized-pollms-timeoutms-"><code>wait(handleOrHash, { for: 'l2' | 'ready' | 'finalized', pollMs?, timeoutMs? })</code></a></h3>
<p>Block until a target phase is reached.</p>
<ul>
<li><code>{ for: 'l2' }</code> ‚Üí resolves <strong>L2 receipt</strong> (<code>TransactionReceiptZKsyncOS</code>) or <code>null</code></li>
<li><code>{ for: 'ready' }</code> ‚Üí resolves <code>null</code> once finalizable</li>
<li><code>{ for: 'finalized' }</code> ‚Üí resolves <strong>L1 receipt</strong> (if found) or <code>null</code></li>
</ul>
<pre><code class="language-ts">const l2Rcpt = await sdk.withdrawals.wait(handle, { for: 'l2' });
await sdk.withdrawals.wait(handle, { for: 'ready', pollMs: 6000, timeoutMs: 15 * 60_000 });
const l1Rcpt = await sdk.withdrawals.wait(handle, { for: 'finalized', pollMs: 7000 });
</code></pre>
<blockquote>
<p>[!TIP]
Default polling is 5500 ms (minimum 1000 ms).
Use <code>timeoutMs</code> to bound long waits gracefully.</p>
</blockquote>
<h3 id="trywaithandleorhash-opts--resulttransactionreceipt--null"><a class="header" href="#trywaithandleorhash-opts--resulttransactionreceipt--null"><code>tryWait(handleOrHash, opts) ‚Üí Result&lt;TransactionReceipt | null&gt;</code></a></h3>
<p>Result-style <code>wait</code>.</p>
<h3 id="finalizel2txhash-hex--promise-status-withdrawalstatus-receipt-transactionreceipt-"><a class="header" href="#finalizel2txhash-hex--promise-status-withdrawalstatus-receipt-transactionreceipt-"><code>finalize(l2TxHash: Hex) ‚Üí Promise&lt;{ status: WithdrawalStatus; receipt?: TransactionReceipt }&gt;</code></a></h3>
<p>Send the <strong>L1 finalize</strong> transaction ‚Äî <strong>only if ready</strong>.
If already finalized, returns the current status without sending.</p>
<pre><code class="language-ts">const { status, receipt } = await sdk.withdrawals.finalize(handle.l2TxHash);
if (status.phase === 'FINALIZED') {
  console.log('L1 tx:', receipt?.transactionHash);
}
</code></pre>
<blockquote>
<p>[!INFO]
If not ready, <code>finalize()</code> throws a typed <code>STATE</code> error.
Use <code>status()</code> or <code>wait(..., { for: 'ready' })</code> first to avoid that.</p>
</blockquote>
<h3 id="tryfinalizel2txhash--promise-ok-true-value--status-withdrawalstatus-receipt-transactionreceipt-----ok-false-error-"><a class="header" href="#tryfinalizel2txhash--promise-ok-true-value--status-withdrawalstatus-receipt-transactionreceipt-----ok-false-error-"><code>tryFinalize(l2TxHash) ‚Üí Promise&lt;{ ok: true; value: { status: WithdrawalStatus; receipt?: TransactionReceipt } } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>finalize</code>.</p>
<h2 id="end-to-end-example"><a class="header" href="#end-to-end-example">End-to-End Example</a></h2>
<h3 id="minimal-happy-path"><a class="header" href="#minimal-happy-path">Minimal Happy Path</a></h3>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create({ token, amount, to });

// L2 inclusion
await sdk.withdrawals.wait(handle, { for: 'l2' });

// Option A: finalize immediately (will throw if not ready)
await sdk.withdrawals.finalize(handle.l2TxHash);

// Option B: wait for readiness, then finalize
await sdk.withdrawals.wait(handle, { for: 'ready' });
await sdk.withdrawals.finalize(handle.l2TxHash);
</code></pre>
<hr />
<h2 id="types-overview-2"><a class="header" href="#types-overview-2">Types (Overview)</a></h2>
<pre><code class="language-ts">export interface WithdrawParams {
  token: Address; // L2 token (ETH sentinel supported)
  amount: bigint; // wei
  to?: Address; // L1 recipient
  l2GasLimit?: bigint;
  l2TxOverrides?: Eip1559GasOverrides;
}

export interface Eip1559GasOverrides {
  gasLimit?: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
}

export interface WithdrawQuote {
  route: 'base' | 'erc20-nonbase';
  summary: {
    route: 'base' | 'erc20-nonbase';
    approvalsNeeded: Array&lt;{ token: Address; spender: Address; amount: bigint }&gt;;
    amounts: {
      transfer: {
        token: Address;
        amount: bigint;
      };
    };
    fees: {
      token: Address;
      maxTotal: bigint;
      mintValue?: bigint;
      l2?: {
        gasLimit: bigint;
        maxFeePerGas: bigint;
        maxPriorityFeePerGas?: bigint;
        total: bigint;
      };
    };
  };
}

export interface WithdrawPlan&lt;TTx = TransactionRequest&gt; {
  route: WithdrawQuote['route'];
  summary: WithdrawQuote;
  steps: Array&lt;{ key: string; kind: string; tx: TTx }&gt;;
}

export interface WithdrawHandle&lt;TTx = TransactionRequest&gt; {
  kind: 'withdrawal';
  l2TxHash: Hex;
  stepHashes: Record&lt;string, Hex&gt;;
  plan: WithdrawPlan&lt;TTx&gt;;
}

export type WithdrawalStatus =
  | { phase: 'UNKNOWN'; l2TxHash: Hex }
  | { phase: 'L2_PENDING'; l2TxHash: Hex }
  | { phase: 'PENDING'; l2TxHash: Hex; key?: unknown }
  | { phase: 'READY_TO_FINALIZE'; l2TxHash: Hex; key: unknown }
  | { phase: 'FINALIZED'; l2TxHash: Hex; key: unknown };

// L2 receipt augmentation returned by wait({ for: 'l2' })
export type TransactionReceiptZKsyncOS = TransactionReceipt &amp; {
  l2ToL1Logs?: Array&lt;unknown&gt;;
};
</code></pre>
<hr />
<h2 id="notes--pitfalls-4"><a class="header" href="#notes--pitfalls-4">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Two chains, two receipts:</strong> Inclusion on <strong>L2</strong> and finalization on <strong>L1</strong> are independent events.</li>
<li><strong>Polling strategy:</strong> For production UIs, prefer <code>wait({ for: 'ready' })</code> then <code>finalize()</code> to avoid premature finalization.</li>
<li><strong>Approvals:</strong> If an ERC-20 requires allowances, <code>create()</code> automatically includes those approval steps.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finalization-services"><a class="header" href="#finalization-services">Finalization Services</a></h1>
<p>Helpers for building and executing <strong>L1 finalization</strong> of L2 withdrawals using the <strong>Ethers adapter</strong>.
These utilities fetch the required L2‚ÜíL1 proof data, check readiness, and submit <code>finalizeDeposit</code> on the <strong>L1 Nullifier</strong> contract.</p>
<blockquote>
<p>Use these services when you need fine-grained control (e.g., preflight simulations, custom gas, external orchestration).
For the high-level path, see <a href="sdk-reference/ethers/./withdrawals.html"><code>sdk.withdrawals.finalize(...)</code></a>.</p>
</blockquote>
<hr />
<h2 id="at-a-glance-5"><a class="header" href="#at-a-glance-5">At a Glance</a></h2>
<ul>
<li><strong>Factory:</strong> <code>createFinalizationServices(client) ‚Üí FinalizationServices</code></li>
<li><strong>Workflow:</strong> <em>fetch params</em> ‚Üí <em>optionally check status</em> ‚Üí <em>simulate readiness</em> ‚Üí <em>submit finalize tx</em></li>
<li><strong>Prereq:</strong> An initialized <strong>EthersClient</strong> (bound to L1 for signing).</li>
</ul>
<h2 id="import--setup"><a class="header" href="#import--setup">Import &amp; Setup</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import {
  createEthersClient,
  createEthersSdk,
  createFinalizationServices
} from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
// optional: const sdk = createEthersSdk(client);

const svc = createFinalizationServices(client);
</code></pre>
<h2 id="minimal-usage-example"><a class="header" href="#minimal-usage-example">Minimal Usage Example</a></h2>
<pre><code class="language-ts">const l2TxHash: Hex = '0x...';

// 1) Build finalize params + discover the L1 Nullifier to call
const { params, nullifier } = await svc.fetchFinalizeDepositParams(l2TxHash);

// 2) (Optional) check finalization
const already = await svc.isWithdrawalFinalized(params);
if (already) {
  console.log('Already finalized on L1');
} else {
  // 3) Dry-run on L1 to confirm readiness (no gas spent)
  const readiness = await svc.simulateFinalizeReadiness(params, nullifier);

  if (readiness.kind === 'READY') {
    // 4) Submit finalize tx
    const { hash, wait } = await svc.finalizeDeposit(params, nullifier);
    console.log('L1 finalize tx:', hash);
    const rcpt = await wait();
    console.log('Finalized in block:', rcpt.blockNumber);
  } else {
    console.warn('Not ready to finalize:', readiness);
  }
}
</code></pre>
<blockquote>
<p>[!TIP]
If you prefer the SDK to handle readiness checks automatically, call <code>sdk.withdrawals.finalize(l2TxHash)</code> instead.</p>
</blockquote>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<h3 id="fetchfinalizedepositparamsl2txhash--promise-params-nullifier-"><a class="header" href="#fetchfinalizedepositparamsl2txhash--promise-params-nullifier-"><code>fetchFinalizeDepositParams(l2TxHash) ‚Üí Promise&lt;{ params, nullifier }&gt;</code></a></h3>
<p>Builds the inputs required by <strong><code>Nullifier.finalizeDeposit</code></strong> for a given <strong>L2 withdrawal tx</strong>.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>l2TxHash</code></td><td><code>Hex</code></td><td>‚úÖ</td><td>L2 withdrawal transaction hash.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>FinalizeDepositParams</code></td><td>Canonical finalize input (proof, indices, message).</td></tr>
<tr><td><code>nullifier</code></td><td><code>Address</code></td><td>L1 Nullifier contract address to call.</td></tr>
</tbody></table>
</div>
<h3 id="iswithdrawalfinalizedkey--promiseboolean"><a class="header" href="#iswithdrawalfinalizedkey--promiseboolean"><code>isWithdrawalFinalized(key) ‚Üí Promise&lt;boolean&gt;</code></a></h3>
<p>Reads the <strong>Nullifier mapping</strong> to determine whether a withdrawal has already been finalized.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key</code></td><td><code>WithdrawalKey</code></td><td>‚úÖ</td><td>Unique key for the withdrawal.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>true</code> if finalized; otherwise <code>false</code>.</p>
<h3 id="simulatefinalizereadinessparams-nullifier--promisefinalizereadiness"><a class="header" href="#simulatefinalizereadinessparams-nullifier--promisefinalizereadiness"><code>simulateFinalizeReadiness(params, nullifier) ‚Üí Promise&lt;FinalizeReadiness&gt;</code></a></h3>
<p>Performs a <strong>static call</strong> on the L1 Nullifier to check whether a <code>finalizeDeposit</code> <strong>would</strong> succeed now (no gas spent).</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>FinalizeDepositParams</code></td><td>‚úÖ</td><td>Prepared finalize input.</td></tr>
<tr><td><code>nullifier</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L1 Nullifier address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>FinalizeReadiness</code></p>
<p>Readiness states (see <a href="sdk-reference/ethers/finalization-services.html#types">Types</a>) include:</p>
<ul>
<li><code>{ kind: 'READY' }</code></li>
<li><code>{ kind: 'FINALIZED' }</code></li>
<li><code>{ kind: 'NOT_READY', reason, detail? }</code> (temporary)</li>
<li><code>{ kind: 'UNFINALIZABLE', reason, detail? }</code> (permanent)</li>
</ul>
<h3 id="finalizedepositparams-nullifier--promise-hash-string-wait---promisetransactionreceipt-"><a class="header" href="#finalizedepositparams-nullifier--promise-hash-string-wait---promisetransactionreceipt-"><code>finalizeDeposit(params, nullifier) ‚Üí Promise&lt;{ hash: string; wait: () =&gt; Promise&lt;TransactionReceipt&gt; }&gt;</code></a></h3>
<p>Sends the <strong>L1 finalize</strong> transaction to the Nullifier with the provided <code>params</code>.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>FinalizeDepositParams</code></td><td>‚úÖ</td><td>Prepared finalize input.</td></tr>
<tr><td><code>nullifier</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L1 Nullifier address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hash</code></td><td><code>string</code></td><td>Submitted L1 transaction hash.</td></tr>
<tr><td><code>wait</code></td><td><code>() =&gt; Promise&lt;TransactionReceipt&gt;</code></td><td>Helper to await on-chain inclusion of the tx.</td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!WARNING]
This method will <strong>revert</strong> if the withdrawal is not ready or invalid.
Prefer calling <code>simulateFinalizeReadiness</code> or using <code>sdk.withdrawals.wait(..., { for: 'ready' })</code> first.</p>
</blockquote>
<h2 id="status--phases"><a class="header" href="#status--phases">Status &amp; Phases</a></h2>
<p>If you are also using <code>sdk.withdrawals.status(...)</code>, the phases align conceptually with readiness:</p>
<div class="table-wrapper"><table><thead><tr><th>Withdrawal Phase</th><th>Meaning</th><th>Readiness interpretation</th></tr></thead><tbody>
<tr><td><code>L2_PENDING</code></td><td>L2 tx not in a block yet</td><td>Not ready</td></tr>
<tr><td><code>L2_INCLUDED</code></td><td>L2 receipt is available</td><td>Not ready (proof not derivable yet)</td></tr>
<tr><td><code>PENDING</code></td><td>Inclusion known; proof data not yet derivable/available</td><td><code>NOT_READY</code></td></tr>
<tr><td><code>READY_TO_FINALIZE</code></td><td>Proof posted; can be finalized on L1</td><td><code>READY</code></td></tr>
<tr><td><code>FINALIZING</code></td><td>L1 finalize tx sent but not yet indexed</td><td>Between <code>READY</code> and <code>FINALIZED</code></td></tr>
<tr><td><code>FINALIZED</code></td><td>Withdrawal finalized on L1</td><td><code>FINALIZED</code></td></tr>
<tr><td><code>FINALIZE_FAILED</code></td><td>Prior L1 finalize reverted</td><td>Likely <code>UNFINALIZABLE</code> until state changes</td></tr>
<tr><td><code>UNKNOWN</code></td><td>No L2 hash or insufficient data</td><td>N/A</td></tr>
</tbody></table>
</div>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<pre><code class="language-ts">// Finalize call input
export interface FinalizeDepositParams {
  chainId: bigint;
  l2BatchNumber: bigint;
  l2MessageIndex: bigint;
  l2Sender: Address;
  l2TxNumberInBatch: number;
  message: Hex;
  merkleProof: Hex[];
}

// Key that identifies a withdrawal in the Nullifier mapping
export type WithdrawalKey = {
  chainIdL2: bigint;
  l2BatchNumber: bigint;
  l2MessageIndex: bigint;
};

// Overall withdrawal state (used by higher-level status helpers)
type WithdrawalPhase =
  | 'L2_PENDING'
  | 'L2_INCLUDED'
  | 'PENDING'
  | 'READY_TO_FINALIZE'
  | 'FINALIZING'
  | 'FINALIZED'
  | 'FINALIZE_FAILED'
  | 'UNKNOWN';

export type WithdrawalStatus = {
  phase: WithdrawalPhase;
  l2TxHash: Hex;
  l1FinalizeTxHash?: Hex;
  key?: WithdrawalKey;
};

// Readiness result returned by simulateFinalizeReadiness(...)
export type FinalizeReadiness =
  | { kind: 'READY' }
  | { kind: 'FINALIZED' }
  | {
      kind: 'NOT_READY';
      // temporary, retry later
      reason: 'paused' | 'batch-not-executed' | 'root-missing' | 'unknown';
      detail?: string;
    }
  | {
      kind: 'UNFINALIZABLE';
      // permanent, won‚Äôt become ready
      reason: 'message-invalid' | 'invalid-chain' | 'settlement-layer' | 'unsupported';
      detail?: string;
    };

// Ethers-bound service surface
export interface FinalizationServices {
  fetchFinalizeDepositParams(
    l2TxHash: Hex,
  ): Promise&lt;{ params: FinalizeDepositParams; nullifier: Address }&gt;;

  isWithdrawalFinalized(key: WithdrawalKey): Promise&lt;boolean&gt;;

  simulateFinalizeReadiness(
    params: FinalizeDepositParams,
    nullifier: Address,
  ): Promise&lt;FinalizeReadiness&gt;;

  finalizeDeposit(
    params: FinalizeDepositParams,
    nullifier: Address,
  ): Promise&lt;{ hash: string; wait: () =&gt; Promise&lt;TransactionReceipt&gt; }&gt;;
}
</code></pre>
<hr />
<h2 id="notes--pitfalls-5"><a class="header" href="#notes--pitfalls-5">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Anyone can finalize:</strong> It‚Äôs permissionless; your backend or a third-party relayer can call <code>finalizeDeposit</code>.</li>
<li><strong>Delay is normal:</strong> Proof availability and posting introduce lag between L2 inclusion and readiness.</li>
<li><strong>Gas/accounting:</strong> Since <code>finalizeDeposit</code> is an <strong>L1 tx</strong>, ensure the L1 signer has ETH for gas.</li>
<li><strong>Error model:</strong> Underlying calls may throw typed errors (e.g., <code>STATE</code>, <code>RPC</code>, <code>VERIFICATION</code>). Use readiness checks to avoid avoidable failures.</li>
</ul>
<h2 id="cross-references"><a class="header" href="#cross-references">Cross-References</a></h2>
<ul>
<li><a href="sdk-reference/ethers/./withdrawals.html">Withdrawals (Ethers)</a></li>
<li><a href="sdk-reference/ethers//overview/finalization.html">Finalization Overview</a></li>
<li><a href="sdk-reference/ethers//overview/status-vs-wait.html">Status vs Wait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<p>Token identity, L1‚ÜîL2 mapping, bridge asset IDs, and chain token facts for ETH, base token, and ERC-20s.</p>
<hr />
<h2 id="at-a-glance-6"><a class="header" href="#at-a-glance-6">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.tokens</code></li>
<li><strong>Capabilities:</strong> resolve tokens, map L1‚áÑL2 addresses, compute <code>assetId</code>, detect base token, WETH helpers, compute bridged addresses.</li>
<li><strong>Auto-handling:</strong> ETH aliases (<code>ETH_ADDRESS</code>, <code>FORMAL_ETH_ADDRESS</code>) and L2 base-token alias are normalized for you.</li>
<li><strong>Error style:</strong> Throwing methods (<code>resolve</code>, <code>toL1Address</code>, etc.); wrap in try/catch or use upstream result-handling.</li>
</ul>
<h2 id="import-5"><a class="header" href="#import-5">Import</a></h2>
<pre><code class="language-ts">import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient, createEthersSdk } from '@matterlabs/zksync-js/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);
// sdk.tokens ‚Üí TokensResource
</code></pre>
<h2 id="quick-start-6"><a class="header" href="#quick-start-6">Quick Start</a></h2>
<p>Resolve a token by L1 address and fetch its L2 counterpart + bridge metadata:</p>
<pre><code class="language-ts">const token = await sdk.tokens.resolve('0xYourTokenL1...');
/*
{
  kind: 'eth' | 'base' | 'erc20',
  l1: Address,
  l2: Address,
  assetId: Hex,
  originChainId: bigint,
  isChainEthBased: boolean,
  baseTokenAssetId: Hex,
  wethL1: Address,
  wethL2: Address,
}
*/
</code></pre>
<p>Map addresses directly:</p>
<pre><code class="language-ts">const l2Addr = await sdk.tokens.toL2Address('0xTokenL1...');
const l1Addr = await sdk.tokens.toL1Address(l2Addr);
</code></pre>
<p>Compute bridge identifiers:</p>
<pre><code class="language-ts">const assetId = await sdk.tokens.assetIdOfL1('0xTokenL1...');
const backL2 = await sdk.tokens.l2TokenFromAssetId(assetId);
</code></pre>
<h2 id="method-reference-3"><a class="header" href="#method-reference-3">Method Reference</a></h2>
<h3 id="resolveref-address--tokenref-opts--chain-l1--l2---promiseresolvedtoken"><a class="header" href="#resolveref-address--tokenref-opts--chain-l1--l2---promiseresolvedtoken"><code>resolve(ref: Address | TokenRef, opts?: { chain?: 'l1' | 'l2' }) ‚Üí Promise&lt;ResolvedToken&gt;</code></a></h3>
<p>Resolve a token reference into full metadata (kind, addresses, assetId, chain facts).</p>
<blockquote>
<p>[!NOTE]
Pass <code>opts.chain: 'l2'</code> when providing an L2 token address; defaults to <code>'l1'</code>.</p>
</blockquote>
<h3 id="l1l2-mapping"><a class="header" href="#l1l2-mapping">L1‚ÜîL2 Mapping</a></h3>
<ul>
<li><code>toL2Address(l1Token: Address) ‚Üí Promise&lt;Address&gt;</code> ‚Äî returns L2 token; base token ‚Üí <code>L2_BASE_TOKEN_ADDRESS</code>, ETH aliases normalized.</li>
<li><code>toL1Address(l2Token: Address) ‚Üí Promise&lt;Address&gt;</code> ‚Äî returns L1 token; ETH alias normalized.</li>
</ul>
<h3 id="bridge-identity"><a class="header" href="#bridge-identity">Bridge Identity</a></h3>
<ul>
<li><code>assetIdOfL1(l1Token: Address) ‚Üí Promise&lt;Hex&gt;</code></li>
<li><code>assetIdOfL2(l2Token: Address) ‚Üí Promise&lt;Hex&gt;</code></li>
<li><code>l2TokenFromAssetId(assetId: Hex) ‚Üí Promise&lt;Address&gt;</code></li>
<li><code>l1TokenFromAssetId(assetId: Hex) ‚Üí Promise&lt;Address&gt;</code></li>
<li><code>originChainId(assetId: Hex) ‚Üí Promise&lt;bigint&gt;</code></li>
</ul>
<h3 id="chain-token-facts"><a class="header" href="#chain-token-facts">Chain Token Facts</a></h3>
<ul>
<li><code>baseTokenAssetId() ‚Üí Promise&lt;Hex&gt;</code> ‚Äî cached.</li>
<li><code>isChainEthBased() ‚Üí Promise&lt;boolean&gt;</code> ‚Äî compares base token assetId vs ETH assetId.</li>
<li><code>wethL1() ‚Üí Promise&lt;Address&gt;</code> ‚Äî cached WETH on L1.</li>
<li><code>wethL2() ‚Üí Promise&lt;Address&gt;</code> ‚Äî cached WETH on L2.</li>
</ul>
<h3 id="address-compute"><a class="header" href="#address-compute">Address Compute</a></h3>
<ul>
<li><code>computeL2BridgedAddress({ originChainId, l1Token }) ‚Üí Promise&lt;Address&gt;</code> ‚Äî deterministic CREATE2 address for a bridged token; handles ETH alias normalization.</li>
</ul>
<h2 id="notes--pitfalls-6"><a class="header" href="#notes--pitfalls-6">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Caching:</strong> <code>baseTokenAssetId</code>, <code>wethL1</code>, <code>wethL2</code>, and the origin chain id are memoized; repeated calls avoid extra RPC hits.</li>
<li><strong>ETH aliases:</strong> Both <code>0xEeeee‚Ä¶</code> (ETH sentinel) and <code>FORMAL_ETH_ADDRESS</code> are normalized to canonical ETH.</li>
<li><strong>Base token alias:</strong> <code>L2_BASE_TOKEN_ADDRESS</code> maps back to the L1 base token via <code>toL1Address</code>.</li>
<li><strong>Error handling:</strong> Methods throw typed errors via the adapters‚Äô error handlers. Wrap with <code>try/catch</code> or rely on higher-level <code>try*</code> patterns.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viemclient"><a class="header" href="#viemclient">ViemClient</a></h1>
<p>Low-level client for the <strong>Viem adapter</strong>.
Provides cached core contract addresses, typed contract access, convenience wallet derivation, and ZKsync RPC integration.</p>
<hr />
<h2 id="at-a-glance-7"><a class="header" href="#at-a-glance-7">At a Glance</a></h2>
<ul>
<li><strong>Factory:</strong> <code>createViemClient({ l1, l2, l1Wallet, l2Wallet?, overrides? }) ‚Üí ViemClient</code></li>
<li><strong>Provides:</strong> cached core <strong>addresses</strong>, typed <strong>contracts</strong>, convenience <strong>wallet access</strong>, and ZKsync <strong>RPC</strong> bound to <code>l2</code>.</li>
<li><strong>Usage:</strong> create this first, then pass it to <code>createViemSdk(client)</code>.</li>
</ul>
<h2 id="import-6"><a class="header" href="#import-6">Import</a></h2>
<pre><code class="language-ts">import { createViemClient } from '@matterlabs/zksync-js/viem';
</code></pre>
<h2 id="quick-start-7"><a class="header" href="#quick-start-7">Quick Start</a></h2>
<pre><code class="language-ts">import { createPublicClient, createWalletClient, http } from 'viem';

// Public clients (reads)
const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });

// Wallet clients (writes)
const l1Wallet = createWalletClient({
  account: /* your L1 account */,
  transport: http(process.env.ETH_RPC!),
});

// Optional dedicated L2 wallet (required for L2 sends, e.g., withdrawals)
const l2Wallet = createWalletClient({
  account: /* can be same key as L1 */,
  transport: http(process.env.ZKSYNC_RPC!),
});

const client = createViemClient({ l1, l2, l1Wallet, l2Wallet });

// Resolve core addresses (cached)
const addrs = await client.ensureAddresses();

// Typed contracts (viem getContract)
const { bridgehub, l1AssetRouter } = await client.contracts();
</code></pre>
<blockquote>
<p>[!TIP]
<code>l1Wallet.account</code> is required.
If you omit <code>l2Wallet</code>, use <code>client.getL2Wallet()</code> ‚Äî it will lazily derive one using the L1 account over the L2 transport.</p>
</blockquote>
<h2 id="createviemclientargs--viemclient"><a class="header" href="#createviemclientargs--viemclient"><code>createViemClient(args) ‚Üí ViemClient</code></a></h2>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>l1</code></td><td><code>viem.PublicClient</code></td><td>‚úÖ</td><td>L1 client for reads and chain metadata.</td></tr>
<tr><td><code>l2</code></td><td><code>viem.PublicClient</code></td><td>‚úÖ</td><td>L2 (ZKsync) client for reads and ZK RPC access.</td></tr>
<tr><td><code>l1Wallet</code></td><td><code>viem.WalletClient&lt;Transport, Chain, Account&gt;</code></td><td>‚úÖ</td><td>L1 wallet (must include an <code>account</code>) used for L1 transactions.</td></tr>
<tr><td><code>l2Wallet</code></td><td><code>viem.WalletClient&lt;Transport, Chain, Account&gt;</code></td><td>‚ùå</td><td>Optional dedicated L2 wallet for L2 sends. Needed for withdrawals.</td></tr>
<tr><td><code>overrides</code></td><td><code>Partial&lt;ResolvedAddresses&gt;</code></td><td>‚ùå</td><td>Optional contract address overrides (forks/tests).</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>ViemClient</code></p>
<h2 id="viemclient-interface"><a class="header" href="#viemclient-interface">ViemClient Interface</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kind</code></td><td><code>'viem'</code></td><td>Adapter discriminator.</td></tr>
<tr><td><code>l1</code></td><td><code>viem.PublicClient</code></td><td>Public L1 client.</td></tr>
<tr><td><code>l2</code></td><td><code>viem.PublicClient</code></td><td>Public L2 (ZKsync) client.</td></tr>
<tr><td><code>l1Wallet</code></td><td><code>viem.WalletClient&lt;T, C, A&gt;</code></td><td>Wallet bound to L1 (carries default <code>account</code>).</td></tr>
<tr><td><code>l2Wallet</code></td><td><code>viem.WalletClient&lt;T, C, A&gt; | undefined</code></td><td>Optional pre-supplied L2 wallet.</td></tr>
<tr><td><code>account</code></td><td><code>viem.Account</code></td><td>Default account (from <code>l1Wallet</code>).</td></tr>
<tr><td><code>zks</code></td><td><code>ZksRpc</code></td><td>ZKsync-specific RPC surface bound to <code>l2</code>.</td></tr>
</tbody></table>
</div>
<h2 id="methods-2"><a class="header" href="#methods-2">Methods</a></h2>
<h3 id="ensureaddresses--promiseresolvedaddresses-1"><a class="header" href="#ensureaddresses--promiseresolvedaddresses-1"><code>ensureAddresses() ‚Üí Promise&lt;ResolvedAddresses&gt;</code></a></h3>
<p>Resolve and cache core contract addresses from chain state (merging any provided overrides).</p>
<pre><code class="language-ts">const a = await client.ensureAddresses();
/*
{
  bridgehub, l1AssetRouter, l1Nullifier, l1NativeTokenVault,
  l2AssetRouter, l2NativeTokenVault, l2BaseTokenSystem
}
*/
</code></pre>
<h3 id="contracts--promise-contracts--1"><a class="header" href="#contracts--promise-contracts--1"><code>contracts() ‚Üí Promise&lt;{ ...contracts }&gt;</code></a></h3>
<p>Return <strong>typed</strong> Viem contracts (<code>getContract</code>) connected to the current clients.</p>
<pre><code class="language-ts">const c = await client.contracts();
const bh = c.bridgehub; // bh.read.*, bh.write.*, bh.simulate.*
</code></pre>
<h3 id="refresh-void-1"><a class="header" href="#refresh-void-1"><code>refresh(): void</code></a></h3>
<p>Clear cached addresses and contracts.
Subsequent calls to <code>ensureAddresses()</code> or <code>contracts()</code> will re-resolve.</p>
<pre><code class="language-ts">client.refresh();
await client.ensureAddresses();
</code></pre>
<h3 id="basetokenchainid-bigint--promiseaddress-1"><a class="header" href="#basetokenchainid-bigint--promiseaddress-1"><code>baseToken(chainId: bigint) ‚Üí Promise&lt;Address&gt;</code></a></h3>
<p>Return the <strong>L1 base-token address</strong> for a given L2 chain via <code>Bridgehub.baseToken(chainId)</code>.</p>
<pre><code class="language-ts">const base = await client.baseToken(324n /* example chain ID */);
</code></pre>
<h3 id="getl2wallet--viemwalletclient"><a class="header" href="#getl2wallet--viemwalletclient"><code>getL2Wallet() ‚Üí viem.WalletClient</code></a></h3>
<p>Return or lazily derive an L2 wallet from the same <code>account</code> as the L1 wallet.</p>
<pre><code class="language-ts">const w = client.getL2Wallet(); // ensures L2 writes are possible
</code></pre>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<h3 id="resolvedaddresses-1"><a class="header" href="#resolvedaddresses-1"><code>ResolvedAddresses</code></a></h3>
<pre><code class="language-ts">type ResolvedAddresses = {
  bridgehub: Address;
  l1AssetRouter: Address;
  l1Nullifier: Address;
  l1NativeTokenVault: Address;
  l2AssetRouter: Address;
  l2NativeTokenVault: Address;
  l2BaseTokenSystem: Address;
};
</code></pre>
<h2 id="notes--pitfalls-7"><a class="header" href="#notes--pitfalls-7">Notes &amp; Pitfalls</a></h2>
<ul>
<li>
<p><strong>Wallet roles:</strong></p>
<ul>
<li>Deposits sign on <strong>L1</strong></li>
<li>Withdrawals sign on <strong>L2</strong></li>
<li>Finalization signs on <strong>L1</strong></li>
</ul>
</li>
<li>
<p><strong>Caching:</strong>
<code>ensureAddresses()</code> and <code>contracts()</code> are cached.
Use <code>refresh()</code> after network or override changes.</p>
</li>
<li>
<p><strong>Overrides:</strong>
For forks or custom deployments, pass <code>overrides</code> during construction.
They merge with on-chain lookups.</p>
</li>
<li>
<p><strong>Error handling:</strong>
Low-level client methods may throw typed SDK errors.
For structured results, prefer the SDK‚Äôs <code>try*</code> variants on higher-level resources.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viemsdk"><a class="header" href="#viemsdk">ViemSdk</a></h1>
<p>High-level SDK built on top of the <strong>Viem adapter</strong> ‚Äî provides deposits, withdrawals, tokens, and contract resources.</p>
<hr />
<h2 id="at-a-glance-8"><a class="header" href="#at-a-glance-8">At a Glance</a></h2>
<ul>
<li>
<p><strong>Factory:</strong> <code>createViemSdk(client) ‚Üí ViemSdk</code></p>
</li>
<li>
<p><strong>Composed resources:</strong> <code>sdk.deposits</code>, <code>sdk.withdrawals</code>, <code>sdk.tokens</code>, <code>sdk.contracts</code></p>
</li>
<li>
<p><strong>Client vs SDK:</strong> The <strong>client</strong> wires RPC/signing; the <strong>SDK</strong> adds high-level flows (<code>quote ‚Üí prepare ‚Üí create ‚Üí wait</code>) plus token and contract resources.</p>
</li>
<li>
<p><strong>Wallets by flow:</strong></p>
<ul>
<li><strong>Deposits (L1 tx):</strong> <code>l1Wallet</code> required</li>
<li><strong>Withdrawals (L2 tx):</strong> <code>l2Wallet</code> required</li>
<li><strong>Finalize (L1 tx):</strong> <code>l1Wallet</code> required</li>
</ul>
</li>
</ul>
<h2 id="import-7"><a class="header" href="#import-7">Import</a></h2>
<pre><code class="language-ts">import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';
</code></pre>
<h2 id="quick-start-8"><a class="header" href="#quick-start-8">Quick Start</a></h2>
<pre><code class="language-ts">import { createPublicClient, createWalletClient, http } from 'viem';
import { createViemClient, createViemSdk, ETH_ADDRESS } from '@matterlabs/zksync-js/viem';

// Public clients (reads)
const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });

// Wallet clients (writes)
const l1Wallet = createWalletClient({
  account: /* your L1 Account */,
  transport: http(process.env.ETH_RPC!),
});

const l2Wallet = createWalletClient({
  account: /* your L2 Account (can be the same key) */,
  transport: http(process.env.ZKSYNC_RPC!),
});

const client = createViemClient({ l1, l2, l1Wallet, l2Wallet });
const sdk = createViemSdk(client);

// Example: deposit 0.05 ETH L1 ‚Üí L2, wait for L2 execution
const handle = await sdk.deposits.create({
  token: ETH_ADDRESS,               // 0x‚Ä¶00 sentinel for ETH
  amount: 50_000_000_000_000_000n,  // 0.05 ETH in wei
  to: l2Wallet.account.address,
});
await sdk.deposits.wait(handle, { for: 'l2' });

// Example: resolve contracts and map an L1 token to its L2 address
const { l1NativeTokenVault } = await sdk.contracts.instances();
const token = await sdk.tokens.resolve('0xYourToken');
console.log(token.l2);
</code></pre>
<blockquote>
<p>[!TIP]
You can construct the client with only the wallets you need for a given flow (e.g., just <code>l2Wallet</code> to create withdrawals; add <code>l1Wallet</code> when you plan to finalize).</p>
</blockquote>
<h2 id="createviemsdkclient--viemsdk"><a class="header" href="#createviemsdkclient--viemsdk"><code>createViemSdk(client) ‚Üí ViemSdk</code></a></h2>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><code>ViemClient</code></td><td>‚úÖ</td><td>Instance returned by <code>createViemClient({ l1, l2, l1Wallet?, l2Wallet? })</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>ViemSdk</code></p>
<blockquote>
<p>[!TIP]
The SDK composes the client with resources: <code>deposits</code>, <code>withdrawals</code>, <code>tokens</code>, and <code>contracts</code>.</p>
</blockquote>
<h2 id="viemsdk-interface"><a class="header" href="#viemsdk-interface">ViemSdk Interface</a></h2>
<h3 id="deposits-depositsresource-1"><a class="header" href="#deposits-depositsresource-1"><code>deposits: DepositsResource</code></a></h3>
<p>L1 ‚Üí L2 flows.
See <a href="sdk-reference/viem/./deposits.html">Deposits</a>.</p>
<h3 id="withdrawals-withdrawalsresource-1"><a class="header" href="#withdrawals-withdrawalsresource-1"><code>withdrawals: WithdrawalsResource</code></a></h3>
<p>L2 ‚Üí L1 flows.
See <a href="sdk-reference/viem/./withdrawals.html">Withdrawals</a>.</p>
<h3 id="tokens-tokensresource-1"><a class="header" href="#tokens-tokensresource-1"><code>tokens: TokensResource</code></a></h3>
<p>Token identity, L1‚áÑL2 mapping, bridge asset IDs, chain token facts.
See <a href="sdk-reference/viem/./tokens.html">Tokens</a>.</p>
<h3 id="contracts-contractsresource-1"><a class="header" href="#contracts-contractsresource-1"><code>contracts: ContractsResource</code></a></h3>
<p>Resolved addresses and connected contract instances.
See <a href="sdk-reference/viem/./contracts.html">Contracts</a>.</p>
<h2 id="contracts-2"><a class="header" href="#contracts-2"><code>contracts</code></a></h2>
<p>Utilities for resolved addresses and connected contracts. Token mapping lives in <code>sdk.tokens</code>.</p>
<h3 id="addresses--promiseresolvedaddresses-2"><a class="header" href="#addresses--promiseresolvedaddresses-2"><code>addresses() ‚Üí Promise&lt;ResolvedAddresses&gt;</code></a></h3>
<p>Resolve core addresses (Bridgehub, routers, vaults, base-token system).</p>
<pre><code class="language-ts">const a = await sdk.contracts.addresses();
</code></pre>
<h3 id="instances--promise-contracts--2"><a class="header" href="#instances--promise-contracts--2"><code>instances() ‚Üí Promise&lt;{ ...contracts }&gt;</code></a></h3>
<p><strong>Typed</strong> Viem contracts for all core components (each exposes <code>.read</code> / <code>.write</code> / <code>.simulate</code>).</p>
<pre><code class="language-ts">const c = await sdk.contracts.instances();
const bridgehub = c.bridgehub;
</code></pre>
<h3 id="one-off-contract-getters-2"><a class="header" href="#one-off-contract-getters-2">One-off Contract Getters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bridgehub()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected Bridgehub contract.</td></tr>
<tr><td><code>l1AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Asset Router.</td></tr>
<tr><td><code>l1NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Native Token Vault.</td></tr>
<tr><td><code>l1Nullifier()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Nullifier contract.</td></tr>
<tr><td><code>l2AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Asset Router contract.</td></tr>
<tr><td><code>l2NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Native Token Vault.</td></tr>
<tr><td><code>l2BaseTokenSystem()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Base Token System.</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const nullifier = await sdk.contracts.l1Nullifier();
</code></pre>
<hr />
<h2 id="notes--pitfalls-8"><a class="header" href="#notes--pitfalls-8">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Wallet placement matters:</strong> Deposits sign on <strong>L1</strong>; withdrawals sign on <strong>L2</strong>; finalization signs on <strong>L1</strong>.</li>
<li><strong>Chain-derived behavior:</strong> Contracts and tokens read from on-chain sources; results depend on connected networks.</li>
<li><strong>Error model:</strong> Resource methods throw typed errors; prefer <code>try*</code> variants on resources for result objects.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contracts-3"><a class="header" href="#contracts-3">Contracts</a></h1>
<p>Resolved addresses and connected core contracts for the Viem adapter.</p>
<hr />
<h2 id="at-a-glance-9"><a class="header" href="#at-a-glance-9">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.contracts</code></li>
<li><strong>Capabilities:</strong> resolve core contract addresses, return typed <code>getContract</code> instances, per-contract getters.</li>
<li><strong>Caching:</strong> addresses and instances are memoized by the client; call <code>client.refresh()</code> to re-resolve.</li>
<li><strong>Token mapping:</strong> use <code>sdk.tokens</code> for L1‚áÑL2 mapping and assetId helpers.</li>
<li><strong>Error style:</strong> Throwing methods (no <code>try*</code> variants).</li>
</ul>
<h2 id="import-8"><a class="header" href="#import-8">Import</a></h2>
<pre><code class="language-ts">import { createPublicClient, createWalletClient, http } from 'viem';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';

const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });
const l1Wallet = createWalletClient({
  account: /* your L1 Account */,
  transport: http(process.env.ETH_RPC!),
});

const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);
// sdk.contracts ‚Üí ContractsResource
</code></pre>
<h2 id="quick-start-9"><a class="header" href="#quick-start-9">Quick Start</a></h2>
<p>Resolve addresses and contract handles:</p>
<pre><code class="language-ts">const addresses = await sdk.contracts.addresses();
const { l1NativeTokenVault, l2AssetRouter } = await sdk.contracts.instances();

const ntv = await sdk.contracts.l1NativeTokenVault();
</code></pre>
<h2 id="method-reference-4"><a class="header" href="#method-reference-4">Method Reference</a></h2>
<h3 id="addresses--promiseresolvedaddresses-3"><a class="header" href="#addresses--promiseresolvedaddresses-3"><code>addresses() ‚Üí Promise&lt;ResolvedAddresses&gt;</code></a></h3>
<p>Resolve core addresses (Bridgehub, routers, vaults, base-token system).</p>
<pre><code class="language-ts">const a = await sdk.contracts.addresses();
/*
{
  bridgehub,
  l1AssetRouter,
  l1Nullifier,
  l1NativeTokenVault,
  l2AssetRouter,
  l2NativeTokenVault,
  l2BaseTokenSystem
}
*/
</code></pre>
<h3 id="instances--promise-contracts--3"><a class="header" href="#instances--promise-contracts--3"><code>instances() ‚Üí Promise&lt;{ ...contracts }&gt;</code></a></h3>
<p>Return <strong>typed</strong> Viem contracts for all core components (each exposes <code>.read</code> / <code>.write</code> / <code>.simulate</code>).</p>
<pre><code class="language-ts">const c = await sdk.contracts.instances();
const bridgehub = c.bridgehub;
</code></pre>
<h3 id="one-off-contract-getters-3"><a class="header" href="#one-off-contract-getters-3">One-off Contract Getters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bridgehub()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected Bridgehub contract.</td></tr>
<tr><td><code>l1AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Asset Router contract.</td></tr>
<tr><td><code>l1NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Native Token Vault.</td></tr>
<tr><td><code>l1Nullifier()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L1 Nullifier contract.</td></tr>
<tr><td><code>l2AssetRouter()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Asset Router contract.</td></tr>
<tr><td><code>l2NativeTokenVault()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Native Token Vault.</td></tr>
<tr><td><code>l2BaseTokenSystem()</code></td><td><code>Promise&lt;Contract&gt;</code></td><td>Connected L2 Base Token System.</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const router = await sdk.contracts.l2AssetRouter();
</code></pre>
<h2 id="notes--pitfalls-9"><a class="header" href="#notes--pitfalls-9">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Caching:</strong> <code>addresses()</code> and <code>instances()</code> are cached by the client; call <code>client.refresh()</code> to force re-resolution.</li>
<li><strong>Token mapping:</strong> For L1‚áÑL2 address mapping, asset IDs, and WETH helpers, use <code>sdk.tokens</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposits-3"><a class="header" href="#deposits-3">Deposits</a></h1>
<p>L1 ‚Üí L2 deposits for ETH and ERC-20 tokens with quote, prepare, create, status, and wait helpers using the <strong>Viem adapter</strong>.</p>
<hr />
<h2 id="at-a-glance-10"><a class="header" href="#at-a-glance-10">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.deposits</code></li>
<li><strong>Common flow:</strong> <code>quote ‚Üí create ‚Üí wait({ for: 'l2' })</code></li>
<li><strong>Auto-routing:</strong> ETH vs ERC-20 and base-token vs non-base handled automatically</li>
<li><strong>Error style:</strong> Throwing methods (<code>quote</code>, <code>prepare</code>, <code>create</code>, <code>wait</code>) + safe variants (<code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>, <code>tryWait</code>)</li>
<li><strong>Token mapping:</strong> Use <code>sdk.tokens</code> for L1‚áÑL2 token lookups and assetIds if you need token metadata ahead of time.</li>
</ul>
<h2 id="import-9"><a class="header" href="#import-9">Import</a></h2>
<pre><code class="language-ts">import {
  createPublicClient,
  createWalletClient,
  http,
  parseEther,
  type Account,
  type Chain,
  type Transport,
  type WalletClient,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';

const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);
const l1 = createPublicClient({ transport: http(L1_RPC) });
const l2 = createPublicClient({ transport: http(L2_RPC) });
const l1Wallet: WalletClient&lt;Transport, Chain, Account&gt; = createWalletClient({
  account,
  transport: http(L1_RPC),
});

// Initialize
const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);
// sdk.deposits ‚Üí DepositsResource
</code></pre>
<hr />
<h2 id="quick-start-10"><a class="header" href="#quick-start-10">Quick Start</a></h2>
<p>Deposit <strong>0.1 ETH</strong> from L1 ‚Üí L2 and wait for <strong>L2 execution</strong>:</p>
<pre><code class="language-ts">const handle = await sdk.deposits.create({
  token: ETH_ADDRESS, // 0x‚Ä¶00 for ETH
  amount: parseEther('0.1'),
  to: account.address,
});

const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' }); // null only if no L1 hash
</code></pre>
<blockquote>
<p>[!TIP]
For UX that never throws, use the <code>try*</code> variants and branch on <code>ok</code>.</p>
</blockquote>
<hr />
<h2 id="route-selection-automatic-2"><a class="header" href="#route-selection-automatic-2">Route Selection (Automatic)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Route</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>eth-base</code></td><td>ETH when L2 base token <strong>is ETH</strong></td></tr>
<tr><td><code>eth-nonbase</code></td><td>ETH when L2 base token <strong>‚â† ETH</strong></td></tr>
<tr><td><code>erc20-base</code></td><td>ERC-20 that <strong>is</strong> the L2 base token</td></tr>
<tr><td><code>erc20-nonbase</code></td><td>ERC-20 that <strong>is not</strong> the L2 base token</td></tr>
</tbody></table>
</div>
<p>You <strong>do not</strong> pass a route; it‚Äôs derived automatically from chain metadata + <code>token</code>.</p>
<h2 id="method-reference-5"><a class="header" href="#method-reference-5">Method Reference</a></h2>
<h3 id="quotep-depositparams--promisedepositquote-1"><a class="header" href="#quotep-depositparams--promisedepositquote-1"><code>quote(p: DepositParams) ‚Üí Promise&lt;DepositQuote&gt;</code></a></h3>
<p>Estimate the deposit operation (route, approvals, gas hints). Does <strong>not</strong> send transactions.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L1 token address. Use <code>0x‚Ä¶00</code> for ETH.</td></tr>
<tr><td><code>amount</code></td><td><code>bigint</code></td><td>‚úÖ</td><td>Amount in wei to deposit.</td></tr>
<tr><td><code>to</code></td><td><code>Address</code></td><td>‚ùå</td><td>L2 recipient address. Defaults to the signer‚Äôs address if omitted.</td></tr>
<tr><td><code>refundRecipient</code></td><td><code>Address</code></td><td>‚ùå</td><td>Optional address on L1 to receive refunds for unspent gas.</td></tr>
<tr><td><code>l2GasLimit</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional manual L2 gas limit override.</td></tr>
<tr><td><code>gasPerPubdata</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional custom gas-per-pubdata value.</td></tr>
<tr><td><code>operatorTip</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional operator tip (in wei) for priority execution.</td></tr>
<tr><td><code>l1TxOverrides</code></td><td><a href="sdk-reference/viem/deposits.html#eip1559gasoverrides"><code>Eip1559GasOverrides</code></a></td><td>‚ùå</td><td>Optional EIP-1559 gas settings for the L1 transaction.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>DepositQuote</code></p>
<pre><code class="language-ts">const q = await sdk.deposits.quote({
  token: ETH_L1,
  amount: parseEther('0.25'),
  to: account.address,
});
/*
{
  route: "eth-base" | "eth-nonbase" | "erc20-base" | "erc20-nonbase",
  summary: {
    route,
    approvalsNeeded: [{ token, spender, amount }],
    amounts: {
      transfer: { token, amount }
    },
    fees: {
      token,
      maxTotal,
      mintValue,
      l1: { gasLimit, maxFeePerGas, maxPriorityFeePerGas, maxTotal },
      l2: { total, baseCost, operatorTip, gasLimit, maxFeePerGas, maxPriorityFeePerGas, gasPerPubdata }
    },
    baseCost,
    mintValue
  }
}
*/
</code></pre>
<blockquote>
<p>[!TIP]
If <code>summary.approvalsNeeded</code> is non-empty (ERC-20), <code>create()</code> will automatically include those steps.</p>
</blockquote>
<h3 id="tryquotep--promise-ok-true-value-depositquote----ok-false-error--1"><a class="header" href="#tryquotep--promise-ok-true-value-depositquote----ok-false-error--1"><code>tryQuote(p) ‚Üí Promise&lt;{ ok: true; value: DepositQuote } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>quote</code>.</p>
<h3 id="preparep-depositparams--promisedepositplantransactionrequest-1"><a class="header" href="#preparep-depositparams--promisedepositplantransactionrequest-1"><code>prepare(p: DepositParams) ‚Üí Promise&lt;DepositPlan&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Build a plan (ordered steps + unsigned txs) without sending.</p>
<p><strong>Returns:</strong> <code>DepositPlan</code></p>
<pre><code class="language-ts">const plan = await sdk.deposits.prepare({ token: ETH_L1, amount: parseEther('0.05'), to });
/*
{
  route,
  summary: DepositQuote,
  steps: [
    { key: "approve:USDC", kind: "approve", tx: TransactionRequest },
    { key: "bridge",       kind: "bridge",  tx: TransactionRequest }
  ]
}
*/
</code></pre>
<h3 id="trypreparep--promise-ok-true-value-depositplan----ok-false-error--1"><a class="header" href="#trypreparep--promise-ok-true-value-depositplan----ok-false-error--1"><code>tryPrepare(p) ‚Üí Promise&lt;{ ok: true; value: DepositPlan } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>prepare</code>.</p>
<h3 id="createp-depositparams--promisedeposithandletransactionrequest-1"><a class="header" href="#createp-depositparams--promisedeposithandletransactionrequest-1"><code>create(p: DepositParams) ‚Üí Promise&lt;DepositHandle&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Prepares and <strong>executes</strong> all required L1 steps.
Returns a handle with the L1 tx hash and per-step hashes.</p>
<p><strong>Returns:</strong> <code>DepositHandle</code></p>
<pre><code class="language-ts">const handle = await sdk.deposits.create({ token, amount, to });
/*
{
  kind: "deposit",
  l1TxHash: Hex,
  stepHashes: Record&lt;string, Hex&gt;,
  plan: DepositPlan
}
*/
</code></pre>
<blockquote>
<p>[!WARNING]
If any step reverts, <code>create()</code> throws a typed error. Prefer <code>tryCreate()</code> to avoid exceptions.</p>
</blockquote>
<h3 id="trycreatep--promise-ok-true-value-deposithandle----ok-false-error--1"><a class="header" href="#trycreatep--promise-ok-true-value-deposithandle----ok-false-error--1"><code>tryCreate(p) ‚Üí Promise&lt;{ ok: true; value: DepositHandle } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>create</code>.</p>
<h3 id="statushandleorhash--promisedepositstatus-1"><a class="header" href="#statushandleorhash--promisedepositstatus-1"><code>status(handleOrHash) ‚Üí Promise&lt;DepositStatus&gt;</code></a></h3>
<p>Resolve current phase for a deposit.
Accepts either a <code>DepositHandle</code> or a raw L1 tx hash.</p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>No L1 hash provided</td></tr>
<tr><td><code>L1_PENDING</code></td><td>L1 receipt not yet found</td></tr>
<tr><td><code>L1_INCLUDED</code></td><td>Included on L1; L2 hash not derivable yet</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 hash known; waiting for L2 receipt</td></tr>
<tr><td><code>L2_EXECUTED</code></td><td>L2 receipt found with <code>status === 1</code></td></tr>
<tr><td><code>L2_FAILED</code></td><td>L2 receipt found with <code>status !== 1</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const s = await sdk.deposits.status(handle);
// { phase, l1TxHash, l2TxHash? }
</code></pre>
<h3 id="waithandleorhash--for-l1--l2---promisetransactionreceipt--null-1"><a class="header" href="#waithandleorhash--for-l1--l2---promisetransactionreceipt--null-1"><code>wait(handleOrHash, { for: 'l1' | 'l2' }) ‚Üí Promise&lt;TransactionReceipt | null&gt;</code></a></h3>
<p>Block until a checkpoint is reached.</p>
<ul>
<li><code>{ for: 'l1' }</code> ‚Üí L1 receipt (or <code>null</code> if no L1 hash)</li>
<li><code>{ for: 'l2' }</code> ‚Üí L2 receipt after canonical execution (or <code>null</code> if no L1 hash)</li>
</ul>
<pre><code class="language-ts">const l1Receipt = await sdk.deposits.wait(handle, { for: 'l1' });
const l2Receipt = await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
<h3 id="trywaithandleorhash-opts--resulttransactionreceipt-1"><a class="header" href="#trywaithandleorhash-opts--resulttransactionreceipt-1"><code>tryWait(handleOrHash, opts) ‚Üí Result&lt;TransactionReceipt&gt;</code></a></h3>
<p>Result-style <code>wait</code>.</p>
<hr />
<h2 id="end-to-end-examples-1"><a class="header" href="#end-to-end-examples-1">End-to-End Examples</a></h2>
<h3 id="eth-deposit-typical-1"><a class="header" href="#eth-deposit-typical-1">ETH Deposit (Typical)</a></h3>
<pre><code class="language-ts">const handle = await sdk.deposits.create({
  token: ETH_ADDRESS,
  amount: parseEther('0.1'),
  to: account.address,
});

await sdk.deposits.wait(handle, { for: 'l2' });
</code></pre>
<h3 id="erc-20-deposit-with-automatic-approvals"><a class="header" href="#erc-20-deposit-with-automatic-approvals">ERC-20 Deposit (with Automatic Approvals)</a></h3>
<pre><code class="language-ts">const handle = await sdk.deposits.create({
  token: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC example
  amount: 1_000_000n, // 1 USDC (6 dp)
  to: account.address,
});

const l1Receipt = await sdk.deposits.wait(handle, { for: 'l1' });
</code></pre>
<h2 id="types-overview-3"><a class="header" href="#types-overview-3">Types (Overview)</a></h2>
<pre><code class="language-ts">export interface DepositParams {
  token: Address; // 0x‚Ä¶00 for ETH
  amount: bigint; // wei
  to?: Address; // L2 recipient
  refundRecipient?: Address;
  l2GasLimit?: bigint;
  gasPerPubdata?: bigint;
  operatorTip?: bigint;
  l1TxOverrides?: Eip1559GasOverrides;
}

export interface Eip1559GasOverrides {
  gasLimit?: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
}

export interface DepositQuote {
  route: 'eth-base' | 'eth-nonbase' | 'erc20-base' | 'erc20-nonbase';
  summary: {
    route: 'eth-base' | 'eth-nonbase' | 'erc20-base' | 'erc20-nonbase';
    approvalsNeeded: Array&lt;{ token: Address; spender: Address; amount: bigint }&gt;;
    amounts: {
      transfer: {
        token: Address;
        amount: bigint;
      };
    };
    fees: {
      token: Address;
      maxTotal: bigint;
      mintValue: bigint;
      l1: {
        gasLimit: bigint;
        maxFeePerGas: bigint;
        maxPriorityFeePerGas: bigint;
        maxTotal: bigint;
      };
      l2: {
        total: bigint;
        baseCost: bigint;
        operatorTip: bigint;
        gasLimit: bigint;
        maxFeePerGas: bigint;
        maxPriorityFeePerGas: bigint;
        gasPerPubdata: bigint;
      };
    };
    baseCost: bigint;
    mintValue: bigint;
  };
}

export interface DepositPlan&lt;TTx = TransactionRequest&gt; {
  route: DepositQuote['route'];
  summary: DepositQuote;
  steps: Array&lt;{ key: string; kind: string; tx: TTx }&gt;;
}

export interface DepositHandle&lt;TTx = TransactionRequest&gt; {
  kind: 'deposit';
  l1TxHash: Hex;
  stepHashes: Record&lt;string, Hex&gt;;
  plan: DepositPlan&lt;TTx&gt;;
}

export type DepositStatus =
  | { phase: 'UNKNOWN'; l1TxHash: Hex }
  | { phase: 'L1_PENDING'; l1TxHash: Hex }
  | { phase: 'L1_INCLUDED'; l1TxHash: Hex }
  | { phase: 'L2_PENDING'; l1TxHash: Hex; l2TxHash: Hex }
  | { phase: 'L2_EXECUTED'; l1TxHash: Hex; l2TxHash: Hex }
  | { phase: 'L2_FAILED'; l1TxHash: Hex; l2TxHash: Hex };
</code></pre>
<blockquote>
<p>[!TIP]
Prefer the <code>try*</code> variants to avoid exceptions and work with structured result objects.</p>
</blockquote>
<hr />
<h2 id="notes--pitfalls-10"><a class="header" href="#notes--pitfalls-10">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>ETH sentinel:</strong> Always use the canonical <code>0x‚Ä¶00</code> address when passing ETH as <code>token</code>.</li>
<li><strong>Receipts timing:</strong> <code>wait({ for: 'l2' })</code> resolves after canonical L2 execution ‚Äî may take longer than L1 inclusion.</li>
<li><strong>Gas hints:</strong> <code>suggestedL2GasLimit</code> and <code>gasPerPubdata</code> are informational; advanced users can override via the prepared plan.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdrawals-3"><a class="header" href="#withdrawals-3">Withdrawals</a></h1>
<p>L2 ‚Üí L1 withdrawals for ETH and ERC-20 tokens with quote, prepare, create, status, wait, and finalize helpers using the <strong>Viem adapter</strong>.</p>
<hr />
<h2 id="at-a-glance-11"><a class="header" href="#at-a-glance-11">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.withdrawals</code></li>
<li><strong>Typical flow:</strong> <code>quote ‚Üí create ‚Üí wait({ for: 'l2' }) ‚Üí wait({ for: 'ready' }) ‚Üí finalize</code></li>
<li><strong>Auto-routing:</strong> ETH vs ERC-20 and base-token vs non-base handled automatically</li>
<li><strong>Error style:</strong> Throwing methods (<code>quote</code>, <code>prepare</code>, <code>create</code>, <code>status</code>, <code>wait</code>, <code>finalize</code>) + safe result variants (<code>tryQuote</code>, <code>tryPrepare</code>, <code>tryCreate</code>, <code>tryWait</code>, <code>tryFinalize</code>)</li>
<li><strong>Token mapping:</strong> Use <code>sdk.tokens</code> if you need L1/L2 token addresses or assetIds ahead of time.</li>
</ul>
<h2 id="import-10"><a class="header" href="#import-10">Import</a></h2>
<pre><code class="language-ts">import {
  createPublicClient,
  createWalletClient,
  http,
  parseEther,
  type Account,
  type Chain,
  type Transport,
  type WalletClient,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';

const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);
const l1 = createPublicClient({ transport: http(L1_RPC) });
const l2 = createPublicClient({ transport: http(L2_RPC) });
const l1Wallet: WalletClient&lt;Transport, Chain, Account&gt; = createWalletClient({
  account,
  transport: http(L1_RPC),
});

// Initialize the SDK
const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);
// sdk.withdrawals ‚Üí WithdrawalsResource
</code></pre>
<h2 id="quick-start-11"><a class="header" href="#quick-start-11">Quick Start</a></h2>
<p>Withdraw <strong>0.1 ETH</strong> from L2 ‚Üí L1 and finalize on L1:</p>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create({
  token: ETH_ADDRESS, // ETH sentinel supported
  amount: parseEther('0.1'),
  to: account.address, // L1 recipient
});

// 1) L2 inclusion (adds l2ToL1Logs if available)
await sdk.withdrawals.wait(handle, { for: 'l2' });

// 2) Wait until finalizable (no side effects)
await sdk.withdrawals.wait(handle, { for: 'ready', pollMs: 6000 });

// 3) Finalize on L1 (no-op if already finalized)
const { status, receipt: l1Receipt } = await sdk.withdrawals.finalize(handle.l2TxHash);
</code></pre>
<blockquote>
<p>[!INFO]
Withdrawals are two-phase: inclusion on <strong>L2</strong>, then <strong>finalization on L1</strong>.
You can call <code>finalize</code> directly, but it will throw if not yet ready.
Prefer <code>wait(..., { for: 'ready' })</code> to avoid premature finalization errors.</p>
</blockquote>
<h2 id="route-selection-automatic-3"><a class="header" href="#route-selection-automatic-3">Route Selection (Automatic)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Route</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>base</code></td><td>Withdrawing the <strong>base token</strong> (ETH or otherwise)</td></tr>
<tr><td><code>erc20-nonbase</code></td><td>Withdrawing an ERC-20 that is <strong>not</strong> the base token</td></tr>
</tbody></table>
</div>
<p>Routes are derived automatically from network metadata and the supplied <code>token</code>.</p>
<h2 id="method-reference-6"><a class="header" href="#method-reference-6">Method Reference</a></h2>
<h3 id="quotep-withdrawparams--promisewithdrawquote-1"><a class="header" href="#quotep-withdrawparams--promisewithdrawquote-1"><code>quote(p: WithdrawParams) ‚Üí Promise&lt;WithdrawQuote&gt;</code></a></h3>
<p>Estimate the operation (route, approvals, gas hints). Does <strong>not</strong> send transactions.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>token</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L2 token (ETH sentinel supported).</td></tr>
<tr><td><code>amount</code></td><td><code>bigint</code></td><td>‚úÖ</td><td>Amount in wei to withdraw.</td></tr>
<tr><td><code>to</code></td><td><code>Address</code></td><td>‚ùå</td><td>L1 recipient. Defaults to the signer‚Äôs address.</td></tr>
<tr><td><code>l2GasLimit</code></td><td><code>bigint</code></td><td>‚ùå</td><td>Optional custom gas limit override for the L2 withdrawal transaction.</td></tr>
<tr><td><code>l2TxOverrides</code></td><td><a href="sdk-reference/viem/withdrawals.html#eip1559gasoverrides"><code>Eip1559GasOverrides</code></a></td><td>‚ùå</td><td>Optional EIP-1559 overrides for the L2 withdrawal transaction.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>WithdrawQuote</code></p>
<pre><code class="language-ts">const q = await sdk.withdrawals.quote({ token, amount, to });
/*
{
  route: "base" | "erc20-nonbase",
  summary: {
    route,
    approvalsNeeded: [{ token, spender, amount }],
    amounts: {
      transfer: { token, amount }
    },
    fees: {
      token,
      maxTotal,
      mintValue,
      l2: { gasLimit, maxFeePerGas, maxPriorityFeePerGas, total }
    }
  }
}
*/
</code></pre>
<h3 id="tryquotep--promise-ok-true-value-withdrawquote----ok-false-error--1"><a class="header" href="#tryquotep--promise-ok-true-value-withdrawquote----ok-false-error--1"><code>tryQuote(p) ‚Üí Promise&lt;{ ok: true; value: WithdrawQuote } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>quote</code>.</p>
<h3 id="preparep-withdrawparams--promisewithdrawplantransactionrequest-1"><a class="header" href="#preparep-withdrawparams--promisewithdrawplantransactionrequest-1"><code>prepare(p: WithdrawParams) ‚Üí Promise&lt;WithdrawPlan&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Builds the plan (ordered L2 steps + unsigned txs) without sending.</p>
<p><strong>Returns:</strong> <code>WithdrawPlan</code></p>
<pre><code class="language-ts">const plan = await sdk.withdrawals.prepare({ token, amount, to });
/*
{
  route,
  summary: WithdrawQuote,
  steps: [
    { key, kind, tx: TransactionRequest },
    // ‚Ä¶
  ]
}
*/
</code></pre>
<h3 id="trypreparep--promise-ok-true-value-withdrawplan----ok-false-error--1"><a class="header" href="#trypreparep--promise-ok-true-value-withdrawplan----ok-false-error--1"><code>tryPrepare(p) ‚Üí Promise&lt;{ ok: true; value: WithdrawPlan } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>prepare</code>.</p>
<h3 id="createp-withdrawparams--promisewithdrawhandletransactionrequest-1"><a class="header" href="#createp-withdrawparams--promisewithdrawhandletransactionrequest-1"><code>create(p: WithdrawParams) ‚Üí Promise&lt;WithdrawHandle&lt;TransactionRequest&gt;&gt;</code></a></h3>
<p>Prepares and <strong>executes</strong> the required <strong>L2</strong> steps.
Returns a handle with the <strong>L2 transaction hash</strong>.</p>
<p><strong>Returns:</strong> <code>WithdrawHandle</code></p>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create({ token, amount, to });
/*
{
  kind: "withdrawal",
  l2TxHash: Hex,
  stepHashes: Record&lt;string, Hex&gt;,
  plan: WithdrawPlan
}
*/
</code></pre>
<blockquote>
<p>[!WARNING]
If any L2 step reverts, <code>create()</code> throws a typed error.
Use <code>tryCreate()</code> to avoid exceptions and return a result object.</p>
</blockquote>
<h3 id="trycreatep--promise-ok-true-value-withdrawhandle----ok-false-error--1"><a class="header" href="#trycreatep--promise-ok-true-value-withdrawhandle----ok-false-error--1"><code>tryCreate(p) ‚Üí Promise&lt;{ ok: true; value: WithdrawHandle } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>create</code>.</p>
<h3 id="statushandleorhash--promisewithdrawalstatus-1"><a class="header" href="#statushandleorhash--promisewithdrawalstatus-1"><code>status(handleOrHash) ‚Üí Promise&lt;WithdrawalStatus&gt;</code></a></h3>
<p>Reports the current phase of a withdrawal.
Accepts a <code>WithdrawHandle</code> or raw <strong>L2 tx hash</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>UNKNOWN</code></td><td>No L2 hash provided</td></tr>
<tr><td><code>L2_PENDING</code></td><td>L2 receipt not yet available</td></tr>
<tr><td><code>PENDING</code></td><td>Included on L2 but not yet finalizable</td></tr>
<tr><td><code>READY_TO_FINALIZE</code></td><td>Can be finalized on L1</td></tr>
<tr><td><code>FINALIZED</code></td><td>Already finalized on L1</td></tr>
</tbody></table>
</div>
<pre><code class="language-ts">const s = await sdk.withdrawals.status(handle);
// { phase, l2TxHash, key? }
</code></pre>
<h3 id="waithandleorhash--for-l2--ready--finalized-pollms-timeoutms--1"><a class="header" href="#waithandleorhash--for-l2--ready--finalized-pollms-timeoutms--1"><code>wait(handleOrHash, { for: 'l2' | 'ready' | 'finalized', pollMs?, timeoutMs? })</code></a></h3>
<p>Wait until the withdrawal reaches a specific phase.</p>
<ul>
<li><code>{ for: 'l2' }</code> ‚Üí Resolves the <strong>L2 receipt</strong> (<code>TransactionReceiptZKsyncOS</code>) or <code>null</code></li>
<li><code>{ for: 'ready' }</code> ‚Üí Resolves <code>null</code> when finalizable</li>
<li><code>{ for: 'finalized' }</code> ‚Üí Resolves the <strong>L1 receipt</strong> (if found) or <code>null</code></li>
</ul>
<pre><code class="language-ts">const l2Rcpt = await sdk.withdrawals.wait(handle, { for: 'l2' });
await sdk.withdrawals.wait(handle, { for: 'ready', pollMs: 6000, timeoutMs: 15 * 60_000 });
const l1Rcpt = await sdk.withdrawals.wait(handle, { for: 'finalized', pollMs: 7000 });
</code></pre>
<blockquote>
<p>[!TIP]
Default polling is <strong>5500 ms</strong> (minimum 1000 ms).
Use <code>timeoutMs</code> for long polling windows.</p>
</blockquote>
<h3 id="trywaithandleorhash-opts--resulttransactionreceipt--null-1"><a class="header" href="#trywaithandleorhash-opts--resulttransactionreceipt--null-1"><code>tryWait(handleOrHash, opts) ‚Üí Result&lt;TransactionReceipt | null&gt;</code></a></h3>
<p>Result-style <code>wait</code>.</p>
<h3 id="finalizel2txhash-hex--promise-status-withdrawalstatus-receipt-transactionreceipt--1"><a class="header" href="#finalizel2txhash-hex--promise-status-withdrawalstatus-receipt-transactionreceipt--1"><code>finalize(l2TxHash: Hex) ‚Üí Promise&lt;{ status: WithdrawalStatus; receipt?: TransactionReceipt }&gt;</code></a></h3>
<p>Send the <strong>L1 finalize</strong> transaction <strong>if ready</strong>.
If already finalized, returns the status without sending.</p>
<pre><code class="language-ts">const { status, receipt } = await sdk.withdrawals.finalize(handle.l2TxHash);
if (status.phase === 'FINALIZED') {
  console.log('L1 tx:', receipt?.transactionHash);
}
</code></pre>
<blockquote>
<p>[!INFO]
If not ready, <code>finalize()</code> throws a typed <code>STATE</code> error.
Use <code>status()</code> or <code>wait(..., { for: 'ready' })</code> before calling to avoid exceptions.</p>
</blockquote>
<h3 id="tryfinalizel2txhash--promise-ok-true-value--status-withdrawalstatus-receipt-transactionreceipt-----ok-false-error--1"><a class="header" href="#tryfinalizel2txhash--promise-ok-true-value--status-withdrawalstatus-receipt-transactionreceipt-----ok-false-error--1"><code>tryFinalize(l2TxHash) ‚Üí Promise&lt;{ ok: true; value: { status: WithdrawalStatus; receipt?: TransactionReceipt } } | { ok: false; error }&gt;</code></a></h3>
<p>Result-style <code>finalize</code>.</p>
<h2 id="end-to-end-example-1"><a class="header" href="#end-to-end-example-1">End-to-End Example</a></h2>
<pre><code class="language-ts">const handle = await sdk.withdrawals.create({ token, amount, to });

// L2 inclusion
await sdk.withdrawals.wait(handle, { for: 'l2' });

// Option A: finalize immediately (throws if not ready)
await sdk.withdrawals.finalize(handle.l2TxHash);

// Option B: wait for readiness, then finalize
await sdk.withdrawals.wait(handle, { for: 'ready' });
await sdk.withdrawals.finalize(handle.l2TxHash);
</code></pre>
<h2 id="types-overview-4"><a class="header" href="#types-overview-4">Types (Overview)</a></h2>
<pre><code class="language-ts">export interface WithdrawParams {
  token: Address; // L2 token (ETH sentinel supported)
  amount: bigint; // wei
  to?: Address; // L1 recipient
  l2GasLimit?: bigint;
  l2TxOverrides?: Eip1559GasOverrides;
}

export interface Eip1559GasOverrides {
  gasLimit?: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
}

export interface WithdrawQuote {
  route: 'base' | 'erc20-nonbase';
  summary: {
    route: 'base' | 'erc20-nonbase';
    approvalsNeeded: Array&lt;{ token: Address; spender: Address; amount: bigint }&gt;;
    amounts: {
      transfer: {
        token: Address;
        amount: bigint;
      };
    };
    fees: {
      token: Address;
      maxTotal: bigint;
      mintValue?: bigint;
      l2?: {
        gasLimit: bigint;
        maxFeePerGas: bigint;
        maxPriorityFeePerGas?: bigint;
        total: bigint;
      };
    };
  };
}

export interface WithdrawPlan&lt;TTx = TransactionRequest&gt; {
  route: WithdrawQuote['route'];
  summary: WithdrawQuote;
  steps: Array&lt;{ key: string; kind: string; tx: TTx }&gt;;
}

export interface WithdrawHandle&lt;TTx = TransactionRequest&gt; {
  kind: 'withdrawal';
  l2TxHash: Hex;
  stepHashes: Record&lt;string, Hex&gt;;
  plan: WithdrawPlan&lt;TTx&gt;;
}

export type WithdrawalStatus =
  | { phase: 'UNKNOWN'; l2TxHash: Hex }
  | { phase: 'L2_PENDING'; l2TxHash: Hex }
  | { phase: 'PENDING'; l2TxHash: Hex; key?: unknown }
  | { phase: 'READY_TO_FINALIZE'; l2TxHash: Hex; key: unknown }
  | { phase: 'FINALIZED'; l2TxHash: Hex; key: unknown };

// L2 receipt augmentation returned by wait({ for: 'l2' })
export type TransactionReceiptZKsyncOS = TransactionReceipt &amp; {
  l2ToL1Logs?: Array&lt;unknown&gt;;
};
</code></pre>
<hr />
<h2 id="notes--pitfalls-11"><a class="header" href="#notes--pitfalls-11">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Two chains, two receipts:</strong> Inclusion on <strong>L2</strong> and finalization on <strong>L1</strong> are separate phases.</li>
<li><strong>Polling strategy:</strong> In production UIs, prefer <code>wait({ for: 'ready' })</code> before <code>finalize()</code> to avoid premature attempts.</li>
<li><strong>Approvals:</strong> If ERC-20 approvals are needed for withdrawal, <code>create()</code> automatically handles them.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finalization-services-1"><a class="header" href="#finalization-services-1">Finalization Services</a></h1>
<p>Helpers for building and executing <strong>L1 finalization</strong> of L2 withdrawals using the <strong>Viem adapter</strong>.
These utilities fetch the required L2‚ÜíL1 proof data, check readiness, and submit <code>finalizeDeposit</code> on the <strong>L1 Nullifier</strong> contract.</p>
<blockquote>
<p>Use these services when you need fine-grained control (preflight simulations, custom gas, external orchestration).
For the high-level path, see <a href="sdk-reference/viem/./withdrawals.html"><code>sdk.withdrawals.finalize(...)</code></a>.</p>
</blockquote>
<hr />
<h2 id="at-a-glance-12"><a class="header" href="#at-a-glance-12">At a Glance</a></h2>
<ul>
<li><strong>Factory:</strong> <code>createFinalizationServices(client) ‚Üí FinalizationServices</code></li>
<li><strong>Workflow:</strong> <em>fetch params</em> ‚Üí <em>optionally check status</em> ‚Üí <em>simulate readiness</em> ‚Üí <em>submit finalize tx</em></li>
<li><strong>Prereq:</strong> An initialized <strong>ViemClient</strong> with an <strong>L1 wallet</strong> (used to sign the L1 finalize tx).</li>
</ul>
<h2 id="import--setup-1"><a class="header" href="#import--setup-1">Import &amp; Setup</a></h2>
<pre><code class="language-ts">import { createPublicClient, createWalletClient, http, type Address } from 'viem';
import { createViemClient, createViemSdk, createFinalizationServices } from '@matterlabs/zksync-js/viem';

const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });

const l1Wallet = createWalletClient({
  account: /* your L1 Account */,
  transport: http(process.env.ETH_RPC!),
});

const client = createViemClient({ l1, l2, l1Wallet });
// optional: const sdk = createViemSdk(client);

const svc = createFinalizationServices(client);
</code></pre>
<h2 id="minimal-usage-example-1"><a class="header" href="#minimal-usage-example-1">Minimal Usage Example</a></h2>
<pre><code class="language-ts">import type { Hex } from 'viem';

const l2TxHash: Hex = '0x...';

// 1) Build finalize params + discover the L1 Nullifier to call
const { params, nullifier } = await svc.fetchFinalizeDepositParams(l2TxHash);

// 2) (Optional) Check if already finalized
const already = await svc.isWithdrawalFinalized({
  chainIdL2: params.chainId,
  l2BatchNumber: params.l2BatchNumber,
  l2MessageIndex: params.l2MessageIndex,
});
if (already) {
  console.log('Already finalized on L1');
} else {
  // 3) Dry-run on L1 to confirm readiness (no gas spent)
  const readiness = await svc.simulateFinalizeReadiness(params, nullifier);

  if (readiness.kind === 'READY') {
    // 4) Submit finalize tx (signed by your L1 wallet)
    const { hash, wait } = await svc.finalizeDeposit(params, nullifier);
    console.log('L1 finalize tx:', hash);
    const rcpt = await wait();
    console.log('Finalized in block:', rcpt.blockNumber);
  } else {
    console.warn('Not ready to finalize:', readiness);
  }
}
</code></pre>
<blockquote>
<p><strong>Tip:</strong> If you prefer the SDK to handle readiness checks automatically, call <code>sdk.withdrawals.finalize(l2TxHash)</code> instead.</p>
</blockquote>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<h3 id="fetchfinalizedepositparamsl2txhash--promise-params-nullifier--1"><a class="header" href="#fetchfinalizedepositparamsl2txhash--promise-params-nullifier--1"><code>fetchFinalizeDepositParams(l2TxHash) ‚Üí Promise&lt;{ params, nullifier }&gt;</code></a></h3>
<p>Builds the inputs required by <strong><code>Nullifier.finalizeDeposit</code></strong> for a given <strong>L2 withdrawal tx</strong>.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>l2TxHash</code></td><td><code>Hex</code></td><td>‚úÖ</td><td>L2 withdrawal transaction hash.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>FinalizeDepositParams</code></td><td>Canonical finalize input (proof, indices, message).</td></tr>
<tr><td><code>nullifier</code></td><td><code>Address</code></td><td>L1 Nullifier contract address to call.</td></tr>
</tbody></table>
</div>
<h3 id="iswithdrawalfinalizedkey--promiseboolean-1"><a class="header" href="#iswithdrawalfinalizedkey--promiseboolean-1"><code>isWithdrawalFinalized(key) ‚Üí Promise&lt;boolean&gt;</code></a></h3>
<p>Reads the <strong>Nullifier mapping</strong> to determine whether a withdrawal has already been finalized.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key</code></td><td><code>WithdrawalKey</code></td><td>‚úÖ</td><td>Unique key for the withdrawal.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>true</code> if finalized; otherwise <code>false</code>.</p>
<h3 id="simulatefinalizereadinessparams-nullifier--promisefinalizereadiness-1"><a class="header" href="#simulatefinalizereadinessparams-nullifier--promisefinalizereadiness-1"><code>simulateFinalizeReadiness(params, nullifier) ‚Üí Promise&lt;FinalizeReadiness&gt;</code></a></h3>
<p>Performs a <strong>static call</strong> on the L1 Nullifier to check whether <code>finalizeDeposit</code> <strong>would</strong> succeed now (no gas spent).</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>FinalizeDepositParams</code></td><td>‚úÖ</td><td>Prepared finalize input.</td></tr>
<tr><td><code>nullifier</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L1 Nullifier address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns:</strong> <code>FinalizeReadiness</code> (see <a href="sdk-reference/viem/finalization-services.html#types">Types</a>).</p>
<h3 id="finalizedepositparams-nullifier--promise-hash-string-wait---promisetransactionreceipt--1"><a class="header" href="#finalizedepositparams-nullifier--promise-hash-string-wait---promisetransactionreceipt--1"><code>finalizeDeposit(params, nullifier) ‚Üí Promise&lt;{ hash: string; wait: () =&gt; Promise&lt;TransactionReceipt&gt; }&gt;</code></a></h3>
<p>Sends the <strong>L1 finalize</strong> transaction to the Nullifier with the provided <code>params</code>.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>FinalizeDepositParams</code></td><td>‚úÖ</td><td>Prepared finalize input.</td></tr>
<tr><td><code>nullifier</code></td><td><code>Address</code></td><td>‚úÖ</td><td>L1 Nullifier address.</td></tr>
</tbody></table>
</div>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hash</code></td><td><code>string</code></td><td>Submitted L1 transaction hash.</td></tr>
<tr><td><code>wait</code></td><td><code>() =&gt; Promise&lt;TransactionReceipt&gt;</code></td><td>Helper to await on-chain inclusion of the tx.</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Warning:</strong> This call will revert if the withdrawal is not ready or invalid.
Prefer <code>simulateFinalizeReadiness</code> or <code>sdk.withdrawals.wait(..., { for: 'ready' })</code> first.</p>
</blockquote>
<h2 id="status--phases-1"><a class="header" href="#status--phases-1">Status &amp; Phases</a></h2>
<p>If you are also using <code>sdk.withdrawals.status(...)</code>, the phases align conceptually with readiness:</p>
<div class="table-wrapper"><table><thead><tr><th>Withdrawal Phase</th><th>Meaning</th><th>Readiness interpretation</th></tr></thead><tbody>
<tr><td><code>L2_PENDING</code></td><td>L2 tx not in a block yet</td><td>Not ready</td></tr>
<tr><td><code>L2_INCLUDED</code></td><td>L2 receipt is available</td><td>Not ready (proof not derivable yet)</td></tr>
<tr><td><code>PENDING</code></td><td>Inclusion known; proof data not yet derivable/available</td><td><code>NOT_READY</code></td></tr>
<tr><td><code>READY_TO_FINALIZE</code></td><td>Proof posted; can be finalized on L1</td><td><code>READY</code></td></tr>
<tr><td><code>FINALIZING</code></td><td>L1 finalize tx sent but not yet indexed</td><td>Between <code>READY</code> and <code>FINALIZED</code></td></tr>
<tr><td><code>FINALIZED</code></td><td>Withdrawal finalized on L1</td><td><code>FINALIZED</code></td></tr>
<tr><td><code>FINALIZE_FAILED</code></td><td>Prior L1 finalize reverted</td><td>Possibly <code>UNFINALIZABLE</code></td></tr>
<tr><td><code>UNKNOWN</code></td><td>No L2 hash or insufficient data</td><td>N/A</td></tr>
</tbody></table>
</div>
<h2 id="types-3"><a class="header" href="#types-3">Types</a></h2>
<pre><code class="language-ts">// Finalize call input
export interface FinalizeDepositParams {
  chainId: bigint;
  l2BatchNumber: bigint;
  l2MessageIndex: bigint;
  l2Sender: Address;
  l2TxNumberInBatch: number;
  message: Hex;
  merkleProof: Hex[];
}

// Key that identifies a withdrawal in the Nullifier mapping
export type WithdrawalKey = {
  chainIdL2: bigint;
  l2BatchNumber: bigint;
  l2MessageIndex: bigint;
};

// Overall withdrawal state (used by higher-level status helpers)
type WithdrawalPhase =
  | 'L2_PENDING'
  | 'L2_INCLUDED'
  | 'PENDING'
  | 'READY_TO_FINALIZE'
  | 'FINALIZING'
  | 'FINALIZED'
  | 'FINALIZE_FAILED'
  | 'UNKNOWN';

export type WithdrawalStatus = {
  phase: WithdrawalPhase;
  l2TxHash: Hex;
  l1FinalizeTxHash?: Hex;
  key?: WithdrawalKey;
};

// Readiness result returned by simulateFinalizeReadiness(...)
export type FinalizeReadiness =
  | { kind: 'READY' }
  | { kind: 'FINALIZED' }
  | {
      kind: 'NOT_READY';
      // temporary, retry later
      reason: 'paused' | 'batch-not-executed' | 'root-missing' | 'unknown';
      detail?: string;
    }
  | {
      kind: 'UNFINALIZABLE';
      // permanent, won‚Äôt become ready
      reason: 'message-invalid' | 'invalid-chain' | 'settlement-layer' | 'unsupported';
      detail?: string;
    };

// Viem-bound service surface
export interface FinalizationServices {
  fetchFinalizeDepositParams(
    l2TxHash: Hex,
  ): Promise&lt;{ params: FinalizeDepositParams; nullifier: Address }&gt;;

  isWithdrawalFinalized(key: WithdrawalKey): Promise&lt;boolean&gt;;

  simulateFinalizeReadiness(
    params: FinalizeDepositParams,
    nullifier: Address,
  ): Promise&lt;FinalizeReadiness&gt;;

  finalizeDeposit(
    params: FinalizeDepositParams,
    nullifier: Address,
  ): Promise&lt;{ hash: string; wait: () =&gt; Promise&lt;TransactionReceipt&gt; }&gt;;
}
</code></pre>
<hr />
<h2 id="notes--pitfalls-12"><a class="header" href="#notes--pitfalls-12">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Anyone can finalize:</strong> The withdrawer, a relayer, or your backend‚Äîfinalization is permissionless.</li>
<li><strong>Delay is expected:</strong> Proof generation/posting introduce lag between L2 inclusion and readiness.</li>
<li><strong>Gas:</strong> Finalization is an <strong>L1 transaction</strong>; ensure the <strong>L1 wallet</strong> has ETH for gas.</li>
<li><strong>Error surface:</strong> Underlying calls can throw typed errors (<code>STATE</code>, <code>RPC</code>, <code>VERIFICATION</code>). Check readiness to avoid avoidable failures.</li>
</ul>
<h2 id="cross-references-1"><a class="header" href="#cross-references-1">Cross-References</a></h2>
<ul>
<li><a href="sdk-reference/viem/./withdrawals.html">Withdrawals (Viem)</a></li>
<li><a href="sdk-reference/viem//overview/finalization.html">Finalization Overview</a></li>
<li><a href="sdk-reference/viem//overview/status-vs-wait.html">Status vs Wait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens-1"><a class="header" href="#tokens-1">Tokens</a></h1>
<p>Token identity, L1‚ÜîL2 mapping, bridge asset IDs, and chain token facts for ETH, base token, and ERC-20s.</p>
<hr />
<h2 id="at-a-glance-13"><a class="header" href="#at-a-glance-13">At a Glance</a></h2>
<ul>
<li><strong>Resource:</strong> <code>sdk.tokens</code></li>
<li><strong>Capabilities:</strong> resolve tokens, map L1‚áÑL2 addresses, compute <code>assetId</code>, detect base token, WETH helpers, predict bridged addresses.</li>
<li><strong>Auto-handling:</strong> ETH aliases (<code>ETH_ADDRESS</code>, <code>FORMAL_ETH_ADDRESS</code>) and L2 base-token alias are normalized for you.</li>
<li><strong>Error style:</strong> Throwing methods; wrap in try/catch or use higher-level <code>try*</code> callers.</li>
</ul>
<h2 id="import-11"><a class="header" href="#import-11">Import</a></h2>
<pre><code class="language-ts">import { http, createPublicClient, createWalletClient, parseEther } from 'viem';
import { createViemClient, createViemSdk } from '@matterlabs/zksync-js/viem';
import { mainnet } from 'viem/chains';

const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!), chain: mainnet });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });
const l1Wallet = createWalletClient({
  transport: http(process.env.ETH_RPC!),
  account: process.env.PRIVATE_KEY! as `0x${string}`,
  chain: mainnet,
});

const client = createViemClient({ l1, l2, l1Wallet });
const sdk = createViemSdk(client);
// sdk.tokens ‚Üí TokensResource
</code></pre>
<h2 id="quick-start-12"><a class="header" href="#quick-start-12">Quick Start</a></h2>
<p>Resolve a token by L1 address and fetch its L2 counterpart + bridge metadata:</p>
<pre><code class="language-ts">const token = await sdk.tokens.resolve('0xYourTokenL1...');
/*
{
  kind: 'eth' | 'base' | 'erc20',
  l1: Address,
  l2: Address,
  assetId: Hex,
  originChainId: bigint,
  isChainEthBased: boolean,
  baseTokenAssetId: Hex,
  wethL1: Address,
  wethL2: Address,
}
*/
</code></pre>
<p>Map addresses directly:</p>
<pre><code class="language-ts">const l2Addr = await sdk.tokens.toL2Address('0xTokenL1...');
const l1Addr = await sdk.tokens.toL1Address(l2Addr);
</code></pre>
<p>Compute bridge identifiers:</p>
<pre><code class="language-ts">const assetId = await sdk.tokens.assetIdOfL1('0xTokenL1...');
const backL2 = await sdk.tokens.l2TokenFromAssetId(assetId);
</code></pre>
<h2 id="method-reference-7"><a class="header" href="#method-reference-7">Method Reference</a></h2>
<h3 id="resolveref-address--tokenref-opts--chain-l1--l2---promiseresolvedtoken-1"><a class="header" href="#resolveref-address--tokenref-opts--chain-l1--l2---promiseresolvedtoken-1"><code>resolve(ref: Address | TokenRef, opts?: { chain?: 'l1' | 'l2' }) ‚Üí Promise&lt;ResolvedToken&gt;</code></a></h3>
<p>Resolve a token reference into full metadata (kind, addresses, assetId, chain facts).</p>
<h3 id="l1l2-mapping-1"><a class="header" href="#l1l2-mapping-1">L1‚ÜîL2 Mapping</a></h3>
<ul>
<li><code>toL2Address(l1Token: Address) ‚Üí Promise&lt;Address&gt;</code> ‚Äî returns L2 token; base token ‚Üí <code>L2_BASE_TOKEN_ADDRESS</code>, ETH aliases normalized.</li>
<li><code>toL1Address(l2Token: Address) ‚Üí Promise&lt;Address&gt;</code> ‚Äî returns L1 token; ETH alias normalized.</li>
</ul>
<h3 id="bridge-identity-1"><a class="header" href="#bridge-identity-1">Bridge Identity</a></h3>
<ul>
<li><code>assetIdOfL1(l1Token: Address) ‚Üí Promise&lt;Hex&gt;</code></li>
<li><code>assetIdOfL2(l2Token: Address) ‚Üí Promise&lt;Hex&gt;</code></li>
<li><code>l2TokenFromAssetId(assetId: Hex) ‚Üí Promise&lt;Address&gt;</code></li>
<li><code>l1TokenFromAssetId(assetId: Hex) ‚Üí Promise&lt;Address&gt;</code></li>
<li><code>originChainId(assetId: Hex) ‚Üí Promise&lt;bigint&gt;</code></li>
</ul>
<h3 id="chain-token-facts-1"><a class="header" href="#chain-token-facts-1">Chain Token Facts</a></h3>
<ul>
<li><code>baseTokenAssetId() ‚Üí Promise&lt;Hex&gt;</code> ‚Äî cached.</li>
<li><code>isChainEthBased() ‚Üí Promise&lt;boolean&gt;</code> ‚Äî compares base token assetId vs ETH assetId.</li>
<li><code>wethL1() ‚Üí Promise&lt;Address&gt;</code> ‚Äî cached WETH on L1.</li>
<li><code>wethL2() ‚Üí Promise&lt;Address&gt;</code> ‚Äî cached WETH on L2.</li>
</ul>
<h3 id="address-prediction"><a class="header" href="#address-prediction">Address Prediction</a></h3>
<ul>
<li><code>computeL2BridgedAddress({ originChainId, l1Token }) ‚Üí Promise&lt;Address&gt;</code> ‚Äî deterministic CREATE2 address for a bridged token; handles ETH alias normalization.</li>
</ul>
<h2 id="notes--pitfalls-13"><a class="header" href="#notes--pitfalls-13">Notes &amp; Pitfalls</a></h2>
<ul>
<li><strong>Caching:</strong> <code>baseTokenAssetId</code>, <code>wethL1</code>, <code>wethL2</code>, and the origin chain id are memoized; repeated calls avoid extra RPC hits.</li>
<li><strong>ETH aliases:</strong> Both <code>0xEeeee‚Ä¶</code> (ETH sentinel) and <code>FORMAL_ETH_ADDRESS</code> are normalized to canonical ETH.</li>
<li><strong>Base token alias:</strong> <code>L2_BASE_TOKEN_ADDRESS</code> maps back to the L1 base token via <code>toL1Address</code>.</li>
<li><strong>Error handling:</strong> Methods throw typed errors via the adapters‚Äô error handlers. Wrap with <code>try/catch</code> or rely on higher-level <code>try*</code> patterns.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
